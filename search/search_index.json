{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\u6b22\u8fce\u6765\u5230 lzx's wiki \u00b6 \u672c\u9879\u76ee\u542f\u52a8\u4e8e 2022 \u5e74 12 \u6708 7 \u65e5 \u76ee\u524d\u6b63\u5728\u5f00\u53d1","title":"\u4e3b\u9875"},{"location":"#\u6b22\u8fce\u6765\u5230-lzxs-wiki","text":"\u672c\u9879\u76ee\u542f\u52a8\u4e8e 2022 \u5e74 12 \u6708 7 \u65e5 \u76ee\u524d\u6b63\u5728\u5f00\u53d1","title":"\u6b22\u8fce\u6765\u5230 lzx's wiki"},{"location":"match/","text":"\u524d\u8a00-\u6bd4\u8d5b\u603b\u7ed3 \u00b6 \u672c\u90e8\u5206\u4e3a lzx \u7684\u6bd4\u8d5b\u603b\u7ed3\uff0c\u6301\u7eed\u66f4\u65b0","title":"\u524d\u8a00"},{"location":"match/#\u524d\u8a00-\u6bd4\u8d5b\u603b\u7ed3","text":"\u672c\u90e8\u5206\u4e3a lzx \u7684\u6bd4\u8d5b\u603b\u7ed3\uff0c\u6301\u7eed\u66f4\u65b0","title":"\u524d\u8a00-\u6bd4\u8d5b\u603b\u7ed3"},{"location":"match/cf1748/","text":"CF1748 \u603b\u7ed3 \u00b6 A \u00b6 \u9898\u610f \u00b6 \u7528 \\(n\\) \u4e2a\u7f16\u53f7\u5206\u522b\u4e3a \\(1\\) ~ \\(n\\) \u7684\u957f\u4e3a \\(\\lfloor \\frac i 2 \\rfloor\\) \uff0c\u5bbd\u4e3a \\(1\\) \u7684\u957f\u65b9\u5f62\u62fc\u4e00\u4e2a\u6b63\u65b9\u5f62\u3002 \u8981\u62fc\u6210\u7684\u6b63\u65b9\u5f62\u8fb9\u957f\u5c3d\u53ef\u80fd\u5927\uff0c \u4f46\u662f\u4e0d\u80fd\u65cb\u8f6c \uff0c\u53ef\u4ee5\u4e0d\u7528\u5230\u6240\u6709\u957f\u65b9\u5f62\u3002 \u601d\u8def \u00b6 \u627e\u89c4\u5f8b\uff0c\u53d1\u73b0\u7b54\u6848\u5c31\u662f\u957f\u65b9\u5f62\u6570\uff08 \\(n\\) \uff09\u9664\u4ee5\u4e8c\uff08\u4e0b\u53d6\u6574\uff09 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> using namespace std ; int T ; void work () { int x ; cin >> x ; cout << ( x + 1 ) / 2 << \" \\n \" ; return ; } int main () { scanf ( \"%d\" , & T ); while ( T -- ) { work (); } return 0 ; } /* Write By : lzx RP++ -------------------- NOTES: */ B \u00b6 \u9898\u610f \u00b6 \u8f93\u51fa\u6bcf\u4e2a\u4e32\uff08\u53ea\u5305\u62ec 0 \u5230 9 \uff09\u4e2d\u591a\u6837\u5316\u7684\u5b57\u4e32\u3002 \u591a\u6837\u5316\uff1a\u6bcf\u4e2a\u5b57\u7b26\u51fa\u73b0\u6b21\u6570\u4e0d\u8d85\u8fc7\u4e0d\u540c\u5b57\u7b26\u6570\u91cf\u3002 \u601d\u8def \u00b6 \u51fa\u73b0\u6b21\u6570\u53ea\u8981\u770b\u6700\u591a\u7684\u5373\u53ef\uff0c\u56e0\u4e3a\u6700\u591a\u7684\u4e0d\u8d85\u8fc7\u5c0f\u7684\u4e5f\u4e0d\u4f1a\uff0c\u8d85\u8fc7\u4e86\u90a3\u5c31\u76f4\u63a5\u4e0d\u884c\u3002 \u7531\u4e8e\u957f\u5ea6\u6700\u591a\u6709 \\(10^5\\) \u6240\u4ee5\u8003\u8651\u524d\u7f00\u548c\u4f18\u5316\uff0c\u679a\u4e3e\u8d77\u59cb\u70b9 \\(i\\) \uff0c\u7136\u540e \\(j\\) \u4ece \\(i\\) \u679a\u4e3e\u7d2f\u52a0\u5e76\u5224\u65ad\u5373\u53ef\u3002 \u4f9d\u65e7 \\(\\texttt{TLE}\\) \u7531\u4e8e\u53ea\u6709 0 \u5230 9 \u6240\u4ee5\u4e0d\u540c\u5b57\u7b26\u6570\u91cf\u6700\u591a\u4e3a \\(10\\) \u6240\u4ee5\u6bcf\u4e2a\u51fa\u73b0\u6b21\u6570\u6700\u591a\u4e3a \\(10\\) \\(10\\) \u4e2a\u6570\u4e5f\u5c31\u662f \\(10 \\times 10 = 100\\) \u4e2a \u6240\u4ee5\u53ea\u8981 \\(j\\) \u4ece \\(i\\) \u5f00\u59cb\u679a\u4e3e\u5230 \\(min\\{i+99,n\\}\\) \u5373\u53ef \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> using namespace std ; int T , n , a [ 10 ], maxn , ss , ans ; char s [ 100010 ]; void work () { ans = 0 ; scanf ( \"%d\" , & n ); scanf ( \"%s\" , s + 1 ); for ( int i = 1 ; i <= n ; i ++ ) { a [ 0 ] = a [ 1 ] = a [ 2 ] = a [ 3 ] = a [ 4 ] = a [ 5 ] = a [ 6 ] = a [ 7 ] = a [ 8 ] = a [ 9 ] = 0 ; maxn = 0 ; ss = 0 ; //\u521d\u59cb\u5316 for ( int j = i ; j <= min ( n , i + 99 ); j ++ ) { if ( a [ s [ j ] -48 ] == 0 ) ss ++ ; //\u5982\u679c\u8fd9\u4e2a\u6570\u4ee5\u524d\u6ca1\u51fa\u73b0\u5c31\u7d2f\u52a0\u6570\u5b57\u4e2a\u6570 a [ s [ j ] -48 ] ++ ; //\u7d2f\u52a0\u8be5\u6570\u5b57\u51fa\u73b0\u4e2a\u6570 maxn = max ( maxn , a [ s [ j ] -48 ]); //\u7edf\u8ba1\u51fa\u73b0\u6700\u591a\u7684\u6570\u5b57\u7684\u51fa\u73b0\u4e2a\u6570 if ( maxn <= ss ) ans ++ ; //\u7b26\u5408\u6027\u8d28\u5c31\u7d2f\u52a0\u7b54\u6848 //cout<<maxn<<\" \"<<ss<<\"\\n\"; } } //cerr<<\"--\"<<ans<<\"\\n\"; printf ( \"%d \\n \" , ans ); return ; } int main () { scanf ( \"%d\" , & T ); while ( T -- ) { work (); } return 0 ; } /* Write By : lzx RP++ -------------------- NOTES: */ C \u00b6 \u9898\u610f \u00b6 \u7ed9\u4f60\u4e00\u4e2a\u6570\u7ec4 \\(a\\) \u95ee\u4f60\u4e00\u5171\u6709\u591a\u5c11\u4e2a \\(i (1 \\le i \\le n)\\) \u6ee1\u8db3 \\(\\sum_{j=1}^{i} = 0\\) \u5176\u4e2d\u4f60\u53ef\u4ee5\u5c06\u6570\u7ec4\u4e2d\u4e3a \\(0\\) \u7684\u4fee\u6539\u6210\u4efb\u610f\u6570\uff08\u4e0d\u9650\u6b21\u6570\uff09 \u95ee\u6700\u591a\u80fd\u83b7\u5f97\u591a\u5c11\u4e2a\u90a3\u6837\u7684 \\(i\\) \u601d\u8def \u00b6 \u6570\u636e\u8fc7\u5927\uff01 DP\uff1f\u8d2a\u5fc3\uff1f \u90fd\u6709\u540e\u6548\u6027\uff0c\u4f46\u6ca1\u6709\u524d\u6548\u6027\uff01 \u4e8e\u662f\u53ef\u4ee5\u5012\u7740\uff0c\u627e\u5230\u6bcf\u4e00\u4e2a \\(0\\) \u6240\u5728\u7684\u4f4d\u7f6e\uff0c\u8bb0\u5f55\u4e0b\u6765 \u4f9d\u6b21\u627e\u5230\u6700\u5927\u7684\u4f4d\u7f6e\u7136\u540e\u7528\u4e00\u4e2a \\(\\texttt{map}\\) \u7edf\u8ba1\u51fa\u73b0\u4e2a\u6570 \u679a\u4e3e\u8303\u56f4 \u4f4d\u7f6e \\(+1\\) \u5230 \u4e0a\u4e00\u4e2a\u4f4d\u7f6e \\(-1\\) \u8fd8\u8981\u628a \\(0\\) \u51fa\u73b0\u7684\u6b21\u6570 \\(+1\\) \u56e0\u4e3a\u53ef\u4ee5\u4f7f\u5230\u8fd9\u4e2a\u4f4d\u7f6e\u548c\u4e3a \\(0\\) \u5c06\u6700\u591a\u6b21\u6570\u7684\u7d2f\u52a0\u5230\u7b54\u6848\u4e2d \u5bf9\u4e8e\u7b2c\u4e00\u4e2a \\(0\\) \u4e4b\u524d\u7684\uff08\u6216\u8005\u4e00\u4e2a \\(0\\) \u90fd\u6ca1\u6709\uff09 \u6211\u4eec\u53ef\u4ee5\u76f4\u63a5\u7d2f\u52a0\u7edf\u8ba1\u548c \\(0\\) \u7684\u4e2a\u6570 \u4ee3\u7801 \u00b6 #include <bits/stdc++.h> #define int long long using namespace std ; int T , a [ 200010 ], lst , n , st [ 200010 ], top ; map < int , int > m ; void work () { int ans = 0 , llll = -114514 ; scanf ( \"%lld\" , & n ); for ( int i = 1 ; i <= n ; i ++ ) { scanf ( \"%lld\" , & a [ i ]); if ( a [ i ] == 0 ) { if ( top == 0 ) { llll = i -1 ; //\u5982\u679c\u7b2c\u4e00\u4e2a\u4e4b\u524d\u7684\u8981\u53e6\u5916\u7b97\uff0c\u8bb0\u5f55\u4e00\u4e0b } st [ ++ top ] = i ; } //\u8bb0\u5f55 0 \u7684\u4f4d\u7f6e } if ( llll == -114514 ) { int cnt = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { cnt += a [ i ]; if ( cnt == 0 ) ans ++ ; } printf ( \"%d \\n \" , ans ); return ; } //\u6574\u4e2a\u6ca1\u6709 0 if ( llll != 0 ) { int cnt = 0 ; for ( int i = 1 ; i <= llll ; i ++ ) { cnt += a [ i ]; if ( cnt == 0 ) ans ++ ; } } //\u7b2c\u4e00\u4e2a\u4e4b\u524d\u7684 lst = n ; while ( top ) { m . clear (); int cnt = 0 ; int l = st [ top ]; top -- ; for ( int i = l + 1 ; i <= lst ; i ++ ) { cnt += a [ i ]; m [ cnt ] ++ ; } //\u7edf\u8ba1\u4e2a\u6570 map < int , int > :: iterator it ; int s0 = m [ 0 ] + 1 ; int ms = 0 , id = 0 ; for ( it = m . begin (); it != m . end (); it ++ ) { if ( it -> second > ms ) { id = it -> first ; ms = it -> second ; } } //\u6253\u64c2 if ( s0 > ms ) { ans += s0 ; } else { ans += ms ; } //\u7d2f\u52a0 lst = l -1 ; //\u8bb0\u5f55\u4e0b\u4e00\u8f6e\u7684\u754c\u9650 } printf ( \"%lld \\n \" , ans ); return ; } signed main () { scanf ( \"%lld\" , & T ); while ( T -- ) { work (); } return 0 ; } /* Write By : lzx RP++ -------------------- NOTES: */","title":"CF1748 \u603b\u7ed3"},{"location":"match/cf1748/#cf1748-\u603b\u7ed3","text":"","title":"CF1748 \u603b\u7ed3"},{"location":"match/cf1748/#a","text":"","title":"A"},{"location":"match/cf1748/#\u9898\u610f","text":"\u7528 \\(n\\) \u4e2a\u7f16\u53f7\u5206\u522b\u4e3a \\(1\\) ~ \\(n\\) \u7684\u957f\u4e3a \\(\\lfloor \\frac i 2 \\rfloor\\) \uff0c\u5bbd\u4e3a \\(1\\) \u7684\u957f\u65b9\u5f62\u62fc\u4e00\u4e2a\u6b63\u65b9\u5f62\u3002 \u8981\u62fc\u6210\u7684\u6b63\u65b9\u5f62\u8fb9\u957f\u5c3d\u53ef\u80fd\u5927\uff0c \u4f46\u662f\u4e0d\u80fd\u65cb\u8f6c \uff0c\u53ef\u4ee5\u4e0d\u7528\u5230\u6240\u6709\u957f\u65b9\u5f62\u3002","title":"\u9898\u610f"},{"location":"match/cf1748/#\u601d\u8def","text":"\u627e\u89c4\u5f8b\uff0c\u53d1\u73b0\u7b54\u6848\u5c31\u662f\u957f\u65b9\u5f62\u6570\uff08 \\(n\\) \uff09\u9664\u4ee5\u4e8c\uff08\u4e0b\u53d6\u6574\uff09","title":"\u601d\u8def"},{"location":"match/cf1748/#\u4ee3\u7801","text":"#include <bits/stdc++.h> using namespace std ; int T ; void work () { int x ; cin >> x ; cout << ( x + 1 ) / 2 << \" \\n \" ; return ; } int main () { scanf ( \"%d\" , & T ); while ( T -- ) { work (); } return 0 ; } /* Write By : lzx RP++ -------------------- NOTES: */","title":"\u4ee3\u7801"},{"location":"match/cf1748/#b","text":"","title":"B"},{"location":"match/cf1748/#\u9898\u610f_1","text":"\u8f93\u51fa\u6bcf\u4e2a\u4e32\uff08\u53ea\u5305\u62ec 0 \u5230 9 \uff09\u4e2d\u591a\u6837\u5316\u7684\u5b57\u4e32\u3002 \u591a\u6837\u5316\uff1a\u6bcf\u4e2a\u5b57\u7b26\u51fa\u73b0\u6b21\u6570\u4e0d\u8d85\u8fc7\u4e0d\u540c\u5b57\u7b26\u6570\u91cf\u3002","title":"\u9898\u610f"},{"location":"match/cf1748/#\u601d\u8def_1","text":"\u51fa\u73b0\u6b21\u6570\u53ea\u8981\u770b\u6700\u591a\u7684\u5373\u53ef\uff0c\u56e0\u4e3a\u6700\u591a\u7684\u4e0d\u8d85\u8fc7\u5c0f\u7684\u4e5f\u4e0d\u4f1a\uff0c\u8d85\u8fc7\u4e86\u90a3\u5c31\u76f4\u63a5\u4e0d\u884c\u3002 \u7531\u4e8e\u957f\u5ea6\u6700\u591a\u6709 \\(10^5\\) \u6240\u4ee5\u8003\u8651\u524d\u7f00\u548c\u4f18\u5316\uff0c\u679a\u4e3e\u8d77\u59cb\u70b9 \\(i\\) \uff0c\u7136\u540e \\(j\\) \u4ece \\(i\\) \u679a\u4e3e\u7d2f\u52a0\u5e76\u5224\u65ad\u5373\u53ef\u3002 \u4f9d\u65e7 \\(\\texttt{TLE}\\) \u7531\u4e8e\u53ea\u6709 0 \u5230 9 \u6240\u4ee5\u4e0d\u540c\u5b57\u7b26\u6570\u91cf\u6700\u591a\u4e3a \\(10\\) \u6240\u4ee5\u6bcf\u4e2a\u51fa\u73b0\u6b21\u6570\u6700\u591a\u4e3a \\(10\\) \\(10\\) \u4e2a\u6570\u4e5f\u5c31\u662f \\(10 \\times 10 = 100\\) \u4e2a \u6240\u4ee5\u53ea\u8981 \\(j\\) \u4ece \\(i\\) \u5f00\u59cb\u679a\u4e3e\u5230 \\(min\\{i+99,n\\}\\) \u5373\u53ef","title":"\u601d\u8def"},{"location":"match/cf1748/#\u4ee3\u7801_1","text":"#include <bits/stdc++.h> using namespace std ; int T , n , a [ 10 ], maxn , ss , ans ; char s [ 100010 ]; void work () { ans = 0 ; scanf ( \"%d\" , & n ); scanf ( \"%s\" , s + 1 ); for ( int i = 1 ; i <= n ; i ++ ) { a [ 0 ] = a [ 1 ] = a [ 2 ] = a [ 3 ] = a [ 4 ] = a [ 5 ] = a [ 6 ] = a [ 7 ] = a [ 8 ] = a [ 9 ] = 0 ; maxn = 0 ; ss = 0 ; //\u521d\u59cb\u5316 for ( int j = i ; j <= min ( n , i + 99 ); j ++ ) { if ( a [ s [ j ] -48 ] == 0 ) ss ++ ; //\u5982\u679c\u8fd9\u4e2a\u6570\u4ee5\u524d\u6ca1\u51fa\u73b0\u5c31\u7d2f\u52a0\u6570\u5b57\u4e2a\u6570 a [ s [ j ] -48 ] ++ ; //\u7d2f\u52a0\u8be5\u6570\u5b57\u51fa\u73b0\u4e2a\u6570 maxn = max ( maxn , a [ s [ j ] -48 ]); //\u7edf\u8ba1\u51fa\u73b0\u6700\u591a\u7684\u6570\u5b57\u7684\u51fa\u73b0\u4e2a\u6570 if ( maxn <= ss ) ans ++ ; //\u7b26\u5408\u6027\u8d28\u5c31\u7d2f\u52a0\u7b54\u6848 //cout<<maxn<<\" \"<<ss<<\"\\n\"; } } //cerr<<\"--\"<<ans<<\"\\n\"; printf ( \"%d \\n \" , ans ); return ; } int main () { scanf ( \"%d\" , & T ); while ( T -- ) { work (); } return 0 ; } /* Write By : lzx RP++ -------------------- NOTES: */","title":"\u4ee3\u7801"},{"location":"match/cf1748/#c","text":"","title":"C"},{"location":"match/cf1748/#\u9898\u610f_2","text":"\u7ed9\u4f60\u4e00\u4e2a\u6570\u7ec4 \\(a\\) \u95ee\u4f60\u4e00\u5171\u6709\u591a\u5c11\u4e2a \\(i (1 \\le i \\le n)\\) \u6ee1\u8db3 \\(\\sum_{j=1}^{i} = 0\\) \u5176\u4e2d\u4f60\u53ef\u4ee5\u5c06\u6570\u7ec4\u4e2d\u4e3a \\(0\\) \u7684\u4fee\u6539\u6210\u4efb\u610f\u6570\uff08\u4e0d\u9650\u6b21\u6570\uff09 \u95ee\u6700\u591a\u80fd\u83b7\u5f97\u591a\u5c11\u4e2a\u90a3\u6837\u7684 \\(i\\)","title":"\u9898\u610f"},{"location":"match/cf1748/#\u601d\u8def_2","text":"\u6570\u636e\u8fc7\u5927\uff01 DP\uff1f\u8d2a\u5fc3\uff1f \u90fd\u6709\u540e\u6548\u6027\uff0c\u4f46\u6ca1\u6709\u524d\u6548\u6027\uff01 \u4e8e\u662f\u53ef\u4ee5\u5012\u7740\uff0c\u627e\u5230\u6bcf\u4e00\u4e2a \\(0\\) \u6240\u5728\u7684\u4f4d\u7f6e\uff0c\u8bb0\u5f55\u4e0b\u6765 \u4f9d\u6b21\u627e\u5230\u6700\u5927\u7684\u4f4d\u7f6e\u7136\u540e\u7528\u4e00\u4e2a \\(\\texttt{map}\\) \u7edf\u8ba1\u51fa\u73b0\u4e2a\u6570 \u679a\u4e3e\u8303\u56f4 \u4f4d\u7f6e \\(+1\\) \u5230 \u4e0a\u4e00\u4e2a\u4f4d\u7f6e \\(-1\\) \u8fd8\u8981\u628a \\(0\\) \u51fa\u73b0\u7684\u6b21\u6570 \\(+1\\) \u56e0\u4e3a\u53ef\u4ee5\u4f7f\u5230\u8fd9\u4e2a\u4f4d\u7f6e\u548c\u4e3a \\(0\\) \u5c06\u6700\u591a\u6b21\u6570\u7684\u7d2f\u52a0\u5230\u7b54\u6848\u4e2d \u5bf9\u4e8e\u7b2c\u4e00\u4e2a \\(0\\) \u4e4b\u524d\u7684\uff08\u6216\u8005\u4e00\u4e2a \\(0\\) \u90fd\u6ca1\u6709\uff09 \u6211\u4eec\u53ef\u4ee5\u76f4\u63a5\u7d2f\u52a0\u7edf\u8ba1\u548c \\(0\\) \u7684\u4e2a\u6570","title":"\u601d\u8def"},{"location":"match/cf1748/#\u4ee3\u7801_2","text":"#include <bits/stdc++.h> #define int long long using namespace std ; int T , a [ 200010 ], lst , n , st [ 200010 ], top ; map < int , int > m ; void work () { int ans = 0 , llll = -114514 ; scanf ( \"%lld\" , & n ); for ( int i = 1 ; i <= n ; i ++ ) { scanf ( \"%lld\" , & a [ i ]); if ( a [ i ] == 0 ) { if ( top == 0 ) { llll = i -1 ; //\u5982\u679c\u7b2c\u4e00\u4e2a\u4e4b\u524d\u7684\u8981\u53e6\u5916\u7b97\uff0c\u8bb0\u5f55\u4e00\u4e0b } st [ ++ top ] = i ; } //\u8bb0\u5f55 0 \u7684\u4f4d\u7f6e } if ( llll == -114514 ) { int cnt = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { cnt += a [ i ]; if ( cnt == 0 ) ans ++ ; } printf ( \"%d \\n \" , ans ); return ; } //\u6574\u4e2a\u6ca1\u6709 0 if ( llll != 0 ) { int cnt = 0 ; for ( int i = 1 ; i <= llll ; i ++ ) { cnt += a [ i ]; if ( cnt == 0 ) ans ++ ; } } //\u7b2c\u4e00\u4e2a\u4e4b\u524d\u7684 lst = n ; while ( top ) { m . clear (); int cnt = 0 ; int l = st [ top ]; top -- ; for ( int i = l + 1 ; i <= lst ; i ++ ) { cnt += a [ i ]; m [ cnt ] ++ ; } //\u7edf\u8ba1\u4e2a\u6570 map < int , int > :: iterator it ; int s0 = m [ 0 ] + 1 ; int ms = 0 , id = 0 ; for ( it = m . begin (); it != m . end (); it ++ ) { if ( it -> second > ms ) { id = it -> first ; ms = it -> second ; } } //\u6253\u64c2 if ( s0 > ms ) { ans += s0 ; } else { ans += ms ; } //\u7d2f\u52a0 lst = l -1 ; //\u8bb0\u5f55\u4e0b\u4e00\u8f6e\u7684\u754c\u9650 } printf ( \"%lld \\n \" , ans ); return ; } signed main () { scanf ( \"%lld\" , & T ); while ( T -- ) { work (); } return 0 ; } /* Write By : lzx RP++ -------------------- NOTES: */","title":"\u4ee3\u7801"},{"location":"match/cfs20220924/","text":"20220924 \u6a21\u62df\u8d5b\u89e3\u9898\u62a5\u544a \u00b6 \u6982\u8981 \u00b6 \u6211 AK \u4e86 ~\uff0csrds\u56e0\u4e3a\u6709Q\u8001\u5e08\u7684\u514d\u8d39\u6d4b\u8bd5\u5957\u9910\uff0c\u624d\u53d1\u73b0\u9898\u76ee\u540d\u9519\u4e86( ~\u3002 \u9898\u76ee\u96be\u5ea6\u4e0d\u5927 \u9898\u76ee \u00b6 T1 \u00b6 \u968f\u4fbf\u811a\u7b97\u4e00\u4e0b\u4eba\u6570\u5b8c\u4e86 \u6bd4\u8d5b\u540e \\(-\\) \u6bd4\u8d5b\u524d \\(+\\) \u664b\u7ea7\u7684\u3002 code: #include <bits/stdc++.h> using namespace std ; int x [ 10 ], y [ 10 ], yin , huang , bai ; int main () { freopen ( \"promotion.in\" , \"r\" , stdin ); freopen ( \"promotion.out\" , \"w\" , stdout ); for ( int i = 1 ; i <= 4 ; i ++ ) { cin >> x [ i ] >> y [ i ]; } bai = y [ 4 ] - x [ 4 ]; huang = y [ 3 ] + bai - x [ 3 ]; yin = y [ 2 ] + huang - x [ 2 ]; cout << yin << \" \\n \" << huang << \" \\n \" << bai << \" \\n \" ; return 0 ; } T2 \u00b6 \u679a\u4e3e boom \u7684\u6e90\u5934\uff0c\u518d bfs \u4e00\u4e0b\uff0c\u628a\u5f53\u524d\u80fd\u8fde\u9501 boom \u7684 boom \u4e86\u3002 #include <bits/stdc++.h> using namespace std ; int n , a [ 110 ], ans ; int vis [ 110 ]; struct node { int x , r ; }; queue < node > q ; void bfs ( int X ) { //int times=0; while ( ! q . empty ()) q . pop (); node l ; l . x = X ; l . r = 1 ; q . push ( l ); while ( ! q . empty ()) { //times++; l = q . front (); q . pop (); int x = l . x , r = l . r ; if ( vis [ x ] || x < 1 || x > n ) continue ; //cerr<<\"**\"<<x<<\" \"<<r<<\"\\n\"; vis [ x ] = 1 ; l . r = r + 1 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( abs ( a [ i ] - a [ x ]) <= r && ! vis [ i ]) { l . x = i ; q . push ( l ); //cerr<<\"**\"<<x<<\" to \"<<i<<\"\\n\"; } } } } int main () { freopen ( \"angry.in\" , \"r\" , stdin ); freopen ( \"angry.out\" , \"w\" , stdout ); cin >> n ; for ( int i = 1 ; i <= n ; i ++ ) { cin >> a [ i ]; } sort ( a + 1 , a + 1 + n ); for ( int i = 1 ; i <= n ; i ++ ) { memset ( vis , 0 , sizeof ( vis )); bfs ( i ); int cnt = 0 ; for ( int j = 1 ; j <= n ; j ++ ) { cnt += vis [ j ]; //cerr<<vis[j]<<\" \"; } ans = max ( ans , cnt ); //cerr<<\"\\n\"; } cout << ans << \" \\n \" ; return 0 ; } T3 \u00b6 \u4ece \\((1,1)\\) \u5f00\u59cb bfs\uff0c\u628a\u5f53\u524d\u80fd\u70b9\u4eae\u7684\u8bbf\u95ee\uff0c\u5982\u679c\u70b9\u4eae\u7684\u56db\u5468\u6709\uff0c\u5c31 \\(\\texttt{push}\\) \u4e00\u4e0b\u3002 #include <bits/stdc++.h> using namespace std ; int n , m , ans ; const int dx [] = { 114514 , 1 , -1 , 0 , 0 }, dy [] = { 1919810 , 0 , 0 , 1 , -1 }; struct NodeV { int x , y ; }; struct NodeBfs { int x , y ; }; vector < NodeV > v [ 110 ][ 110 ]; bool vis [ 110 ][ 110 ], islight [ 110 ][ 110 ]; queue < NodeBfs > q ; int main () { freopen ( \"lightson.in\" , \"r\" , stdin ); freopen ( \"lightson.out\" , \"w\" , stdout ); scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= m ; i ++ ) { int x , y , a , b ; scanf ( \"%d%d%d%d\" , & x , & y , & a , & b ); v [ x ][ y ]. push_back ({ a , b }); } q . push ({ 1 , 1 }); while ( ! q . empty ()) { int x = q . front (). x , y = q . front (). y ; q . pop (); if ( x < 1 || y < 1 || x > n || y > n || vis [ x ][ y ]) continue ; vis [ x ][ y ] = 1 ; islight [ x ][ y ] = 1 ; for ( int i = 0 ; i < v [ x ][ y ]. size (); i ++ ) { int nx = v [ x ][ y ][ i ]. x ; int ny = v [ x ][ y ][ i ]. y ; islight [ nx ][ ny ] = 1 ; if ( vis [ nx ][ ny ] == 0 ) { if ( vis [ nx -1 ][ ny ] || vis [ nx + 1 ][ ny ] || vis [ nx ][ ny -1 ] || vis [ nx ][ ny + 1 ]) q . push ({ nx , ny }); } } for ( int i = 1 ; i <= 4 ; i ++ ) { int nx = x + dx [ i ], ny = y + dy [ i ]; if ( ! vis [ x ][ y ] || ! islight [ nx ][ ny ]) continue ; q . push ({ nx , ny }); } } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { //cerr<<islight[i][j]; ans += islight [ i ][ j ]; } //cerr<<\"\\n\"; } cout << ans << \" \\n \" ; return 0 ; } T4 \u00b6 \u6211\u592a\u83dc\u4e86\uff0c\u4e0d\u4f1a\u7528 DP\u3002 \u53ef\u4ee5\u8003\u8651\u51cf\u534a\u53ea\u4f1a\u5bf9\u4e00\u6b21\u5f71\u54cd(\u56e0\u4e3a\u5982\u679c\u4e24\u6b21\u53ca\u4ee5\u4e0a\u5c31\u53ef\u4ee5\u6362\u6210\u6574\u7684 \\(+\\) \u4e00\u534a) \u679a\u4e3e \\(4\\) \u79cd\u60c5\u51b5\u5373\u53ef #include <bits/stdc++.h> #define LL long long using namespace std ; LL T , t , a , b , c , d , ans = 11919810 ; int main () { freopen ( \"feast.in\" , \"r\" , stdin ); freopen ( \"feast.out\" , \"w\" , stdout ); cin >> T >> a >> b ; if ( a < b ) swap ( a , b ); T *= 2 ; c = a ; d = b ; a *= 2 ; b *= 2 ; //the fang'an of 1st t = T ; for ( int i = 0 ; i <= t / a ; i ++ ) { ans = min ( ans , t - ( i * a ) - ( t - i * a ) / b * b ); //cerr<<ans<<\"\\n\"; } //the fang'an of 2nd t = T - c ; for ( int i = 0 ; i <= t / a ; i ++ ) { ans = min ( ans , t - ( i * a ) - ( t - i * a ) / b * b ); //cerr<<ans<<\"\\n\"; } //the fang'an of 3rd t = T - d ; for ( int i = 0 ; i <= t / a ; i ++ ) { ans = min ( ans , t - ( i * a ) - ( t - i * a ) / b * b ); //cerr<<ans<<\"\\n\"; } //the fang'an of 4th t = T - c - d ; for ( int i = 0 ; i <= t / a ; i ++ ) { ans = min ( ans , t - ( i * a ) - ( t - i * a ) / b * b ); //cerr<<ans<<\"\\n\"; } //cerr<<ans<<\"\\n\"; cout << ( T - ans ) / 2 << \" \\n \" ; return 0 ; } /* 4 possible 1st all do not use 2nd use a/2 3rd use b/2 4th use (a+b)/2 */","title":"20220924 \u6a21\u62df\u8d5b\u89e3\u9898\u62a5\u544a"},{"location":"match/cfs20220924/#20220924-\u6a21\u62df\u8d5b\u89e3\u9898\u62a5\u544a","text":"","title":"20220924 \u6a21\u62df\u8d5b\u89e3\u9898\u62a5\u544a"},{"location":"match/cfs20220924/#\u6982\u8981","text":"\u6211 AK \u4e86 ~\uff0csrds\u56e0\u4e3a\u6709Q\u8001\u5e08\u7684\u514d\u8d39\u6d4b\u8bd5\u5957\u9910\uff0c\u624d\u53d1\u73b0\u9898\u76ee\u540d\u9519\u4e86( ~\u3002 \u9898\u76ee\u96be\u5ea6\u4e0d\u5927","title":"\u6982\u8981"},{"location":"match/cfs20220924/#\u9898\u76ee","text":"","title":"\u9898\u76ee"},{"location":"match/cfs20220924/#t1","text":"\u968f\u4fbf\u811a\u7b97\u4e00\u4e0b\u4eba\u6570\u5b8c\u4e86 \u6bd4\u8d5b\u540e \\(-\\) \u6bd4\u8d5b\u524d \\(+\\) \u664b\u7ea7\u7684\u3002 code: #include <bits/stdc++.h> using namespace std ; int x [ 10 ], y [ 10 ], yin , huang , bai ; int main () { freopen ( \"promotion.in\" , \"r\" , stdin ); freopen ( \"promotion.out\" , \"w\" , stdout ); for ( int i = 1 ; i <= 4 ; i ++ ) { cin >> x [ i ] >> y [ i ]; } bai = y [ 4 ] - x [ 4 ]; huang = y [ 3 ] + bai - x [ 3 ]; yin = y [ 2 ] + huang - x [ 2 ]; cout << yin << \" \\n \" << huang << \" \\n \" << bai << \" \\n \" ; return 0 ; }","title":"T1"},{"location":"match/cfs20220924/#t2","text":"\u679a\u4e3e boom \u7684\u6e90\u5934\uff0c\u518d bfs \u4e00\u4e0b\uff0c\u628a\u5f53\u524d\u80fd\u8fde\u9501 boom \u7684 boom \u4e86\u3002 #include <bits/stdc++.h> using namespace std ; int n , a [ 110 ], ans ; int vis [ 110 ]; struct node { int x , r ; }; queue < node > q ; void bfs ( int X ) { //int times=0; while ( ! q . empty ()) q . pop (); node l ; l . x = X ; l . r = 1 ; q . push ( l ); while ( ! q . empty ()) { //times++; l = q . front (); q . pop (); int x = l . x , r = l . r ; if ( vis [ x ] || x < 1 || x > n ) continue ; //cerr<<\"**\"<<x<<\" \"<<r<<\"\\n\"; vis [ x ] = 1 ; l . r = r + 1 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( abs ( a [ i ] - a [ x ]) <= r && ! vis [ i ]) { l . x = i ; q . push ( l ); //cerr<<\"**\"<<x<<\" to \"<<i<<\"\\n\"; } } } } int main () { freopen ( \"angry.in\" , \"r\" , stdin ); freopen ( \"angry.out\" , \"w\" , stdout ); cin >> n ; for ( int i = 1 ; i <= n ; i ++ ) { cin >> a [ i ]; } sort ( a + 1 , a + 1 + n ); for ( int i = 1 ; i <= n ; i ++ ) { memset ( vis , 0 , sizeof ( vis )); bfs ( i ); int cnt = 0 ; for ( int j = 1 ; j <= n ; j ++ ) { cnt += vis [ j ]; //cerr<<vis[j]<<\" \"; } ans = max ( ans , cnt ); //cerr<<\"\\n\"; } cout << ans << \" \\n \" ; return 0 ; }","title":"T2"},{"location":"match/cfs20220924/#t3","text":"\u4ece \\((1,1)\\) \u5f00\u59cb bfs\uff0c\u628a\u5f53\u524d\u80fd\u70b9\u4eae\u7684\u8bbf\u95ee\uff0c\u5982\u679c\u70b9\u4eae\u7684\u56db\u5468\u6709\uff0c\u5c31 \\(\\texttt{push}\\) \u4e00\u4e0b\u3002 #include <bits/stdc++.h> using namespace std ; int n , m , ans ; const int dx [] = { 114514 , 1 , -1 , 0 , 0 }, dy [] = { 1919810 , 0 , 0 , 1 , -1 }; struct NodeV { int x , y ; }; struct NodeBfs { int x , y ; }; vector < NodeV > v [ 110 ][ 110 ]; bool vis [ 110 ][ 110 ], islight [ 110 ][ 110 ]; queue < NodeBfs > q ; int main () { freopen ( \"lightson.in\" , \"r\" , stdin ); freopen ( \"lightson.out\" , \"w\" , stdout ); scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= m ; i ++ ) { int x , y , a , b ; scanf ( \"%d%d%d%d\" , & x , & y , & a , & b ); v [ x ][ y ]. push_back ({ a , b }); } q . push ({ 1 , 1 }); while ( ! q . empty ()) { int x = q . front (). x , y = q . front (). y ; q . pop (); if ( x < 1 || y < 1 || x > n || y > n || vis [ x ][ y ]) continue ; vis [ x ][ y ] = 1 ; islight [ x ][ y ] = 1 ; for ( int i = 0 ; i < v [ x ][ y ]. size (); i ++ ) { int nx = v [ x ][ y ][ i ]. x ; int ny = v [ x ][ y ][ i ]. y ; islight [ nx ][ ny ] = 1 ; if ( vis [ nx ][ ny ] == 0 ) { if ( vis [ nx -1 ][ ny ] || vis [ nx + 1 ][ ny ] || vis [ nx ][ ny -1 ] || vis [ nx ][ ny + 1 ]) q . push ({ nx , ny }); } } for ( int i = 1 ; i <= 4 ; i ++ ) { int nx = x + dx [ i ], ny = y + dy [ i ]; if ( ! vis [ x ][ y ] || ! islight [ nx ][ ny ]) continue ; q . push ({ nx , ny }); } } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { //cerr<<islight[i][j]; ans += islight [ i ][ j ]; } //cerr<<\"\\n\"; } cout << ans << \" \\n \" ; return 0 ; }","title":"T3"},{"location":"match/cfs20220924/#t4","text":"\u6211\u592a\u83dc\u4e86\uff0c\u4e0d\u4f1a\u7528 DP\u3002 \u53ef\u4ee5\u8003\u8651\u51cf\u534a\u53ea\u4f1a\u5bf9\u4e00\u6b21\u5f71\u54cd(\u56e0\u4e3a\u5982\u679c\u4e24\u6b21\u53ca\u4ee5\u4e0a\u5c31\u53ef\u4ee5\u6362\u6210\u6574\u7684 \\(+\\) \u4e00\u534a) \u679a\u4e3e \\(4\\) \u79cd\u60c5\u51b5\u5373\u53ef #include <bits/stdc++.h> #define LL long long using namespace std ; LL T , t , a , b , c , d , ans = 11919810 ; int main () { freopen ( \"feast.in\" , \"r\" , stdin ); freopen ( \"feast.out\" , \"w\" , stdout ); cin >> T >> a >> b ; if ( a < b ) swap ( a , b ); T *= 2 ; c = a ; d = b ; a *= 2 ; b *= 2 ; //the fang'an of 1st t = T ; for ( int i = 0 ; i <= t / a ; i ++ ) { ans = min ( ans , t - ( i * a ) - ( t - i * a ) / b * b ); //cerr<<ans<<\"\\n\"; } //the fang'an of 2nd t = T - c ; for ( int i = 0 ; i <= t / a ; i ++ ) { ans = min ( ans , t - ( i * a ) - ( t - i * a ) / b * b ); //cerr<<ans<<\"\\n\"; } //the fang'an of 3rd t = T - d ; for ( int i = 0 ; i <= t / a ; i ++ ) { ans = min ( ans , t - ( i * a ) - ( t - i * a ) / b * b ); //cerr<<ans<<\"\\n\"; } //the fang'an of 4th t = T - c - d ; for ( int i = 0 ; i <= t / a ; i ++ ) { ans = min ( ans , t - ( i * a ) - ( t - i * a ) / b * b ); //cerr<<ans<<\"\\n\"; } //cerr<<ans<<\"\\n\"; cout << ( T - ans ) / 2 << \" \\n \" ; return 0 ; } /* 4 possible 1st all do not use 2nd use a/2 3rd use b/2 4th use (a+b)/2 */","title":"T4"},{"location":"match/cfs20221004/","text":"\u6982\u8981 \u00b6 \u539f\u672c\u538b\u7ebf\u6ca1\u6709 U\u76d8~~\uff0c\u4f46\u7531\u4e8e\u4f1f\u5927\u7684 cyy \u82f1\u52c7\u8131\u63a7\uff0c\u6210\u529f\u628a U\u76d8\u8ba9\u7ed9\u4e86\u6211~~\u3002 \u9898\u76ee\u8fd8\u7b97\u7b80\u5355\uff0c\u5c31\u662f\u6709\u70b9\u5c31\u5751\u3002 \u9898\u76ee \u00b6 T1 \u00b6 \u5c31\u4e00\u4e2a\u7ed3\u6784\u4f53\u6392\u5e8f\uff0c\u4f46\u662f\u6ce8\u610f \u524d\u9762\u6709 \\(k\\) \u4e2a\u5b66\u751f\u6392\u540d\u6bd4\u4ed6\u9ad8\uff0c\u4e14\u5e74\u7ea7\u6bd4\u4ed6\u4f4e\u3002 \u5373 \u5e73\u5206\u4f46\u5e74\u7ea7\u4f4e\u4e5f\u7b97\u3002 #include <bits/stdc++.h> using namespace std ; int n ; struct node { int s , g ; } a [ 210 ]; bool cmp ( node s1 , node s2 ) { if ( s1 . s == s2 . s ) { return s1 . g < s2 . g ; } return s1 . s > s2 . s ; } int main () { freopen ( \"paiming.in\" , \"r\" , stdin ); freopen ( \"paiming.out\" , \"w\" , stdout ); cin >> n ; for ( int i = 1 ; i <= n ; i ++ ) { cin >> a [ i ]. s >> a [ i ]. g ; } sort ( a + 1 , a + 1 + n , cmp ); for ( int i = 1 ; i <= n ; i ++ ) { int cnt = 0 ; for ( int j = 1 ; j < i ; j ++ ) { if ( a [ j ]. g < a [ i ]. g ) { cnt ++ ; } } cout << cnt << \" \\n \" ; } return 0 ; } T2 \u00b6 \\(\\texttt{DFS/BFS}\\) \u6211\u7528\u7684 \\(\\texttt{DFS}\\) \uff0c\u4f46 T \u4e86\u4e00\u4e2a\u70b9\u3002 \u6362\u4e86\u4e00\u79cd\u601d\u8def\u7684 \\(\\texttt{DFS}\\) \uff0c\u5bf9\u4e86\u3002 #include <bits/stdc++.h> using namespace std ; int hill , lake , n , m , mp [ 1010 ][ 1010 ]; bool vis [ 1010 ][ 1010 ], vvis [ 1010 ][ 1010 ], maxn , minn ; const int dx [] = { 114514 , 1 , -1 , 0 , 0 }, dy [] = { 1919810 , 0 , 0 , 1 , -1 }; void dfs ( int z , int x , int y ) { vis [ x ][ y ] = 1 ; for ( int i = 1 ; i <= 4 ; i ++ ) { int nx = x + dx [ i ], ny = y + dy [ i ]; if ( nx < 1 || ny < 1 || nx > n || ny > m || ( vis [ nx ][ ny ] && mp [ nx ][ ny ] == z )) { continue ; } if ( mp [ nx ][ ny ] > z ) { maxn = 1 ; continue ; } if ( mp [ nx ][ ny ] < z ) { minn = 1 ; continue ; } dfs ( mp [ nx ][ ny ], nx , ny ); } } int main () { freopen ( \"seek.in\" , \"r\" , stdin ); freopen ( \"seek.out\" , \"w\" , stdout ); scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { scanf ( \"%d\" , & mp [ i ][ j ]); } } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { if ( vis [ i ][ j ]) { continue ; } maxn = 0 ; minn = 0 ; //memset(vvis,0,sizeof(vvis)); dfs ( mp [ i ][ j ], i , j ); if ( minn && ( ! maxn )) //it is a beautiful mountain { hill ++ ; } if (( ! minn ) && maxn ) //it is a wonderful lake { lake ++ ; } } } cout << lake << \" \" << hill << \" \\n \" ; return 0 ; } T3 \u00b6 \u6570\u5b66\u9898 \u679a\u4e3e\u4e24\u70b9\u540e\u9000\u51fa\u7b2c\u4e09\u7b2c\u56db\u70b9\uff0c\u4e0d\u4f1a T\u3002 \u7b97\u9762\u79ef\u5c31\u62c6\u6210 \\(4\\) \u4e2a\u4e09\u89d2 \\(+\\) \\(1\\) \u4e2a\u6b63\u65b9\u5f62\uff08\u8f6c\u659c\u4e3a\u6b63\uff09 \u5177\u4f53\u53ef\u4ee5\u53c2\u8003 chenyuxuan \u5de8\u4f6c\u5199\u7684 click here #include <bits/stdc++.h> using namespace std ; int n , ans ; struct node { int x , y ; } a [ 3010 ]; bitset < 5010 > mp [ 5010 ]; int main () { freopen ( \"ruin.in\" , \"r\" , stdin ); freopen ( \"ruin.out\" , \"w\" , stdout ); cin >> n ; for ( int i = 1 ; i <= n ; i ++ ) { cin >> a [ i ]. x >> a [ i ]. y ; mp [ a [ i ]. x ][ a [ i ]. y ] = 1 ; } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( j == i ) continue ; if ( a [ j ]. x <= a [ i ]. x ) continue ; int dx = a [ j ]. x - a [ i ]. x ; int dy = a [ j ]. y - a [ i ]. y ; int x3 = a [ j ]. x - dy ; int y3 = a [ j ]. y + dx ; int x4 = x3 - dx ; int y4 = y3 - dy ; //cerr<<x3<<\" \"<<y3<<\" - \"<<x4<<\" \"<<y4<<\"\\n\"; if ( x3 > 5000 || x4 > 5000 || x3 < 0 || x4 < 0 || y3 > 5000 || y4 > 5000 || y3 < 0 || y4 < 0 ) { continue ; } if ( mp [ x3 ][ y3 ] && mp [ x4 ][ y4 ]) { ans = max ( ans , abs ( a [ j ]. x - a [ i ]. x ) * abs ( a [ j ]. y - a [ i ]. y ) * 2 + ( min ( a [ j ]. x , x3 ) - max ( a [ i ]. x , x4 )) * ( min ( y3 , y4 ) - max ( a [ i ]. y , a [ j ]. y ))); } } } cout << ans << \" \\n \" ; return 0 ; } T4 \u00b6 \u8fde\u73af\u7206\u70b8\u3002 \u4e8c\u5206\u5224\u65ad\u4e2d\u95f4\u76f8\u9694\u8ddd\u79bb\u662f\u5426\u5927\u4e8e \\(mid\\) \u3002 #include <bits/stdc++.h> using namespace std ; int n , k , a [ 50010 ], b [ 50010 ]; bool p ( int x ) { int s = 0 , pos = -2000114514 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( pos + x < a [ i ]) { s ++ ; } pos = a [ i ]; } return ( s <= k ); } int main () { freopen ( \"angry.in\" , \"r\" , stdin ); freopen ( \"angry.out\" , \"w\" , stdout ); cin >> n >> k ; for ( int i = 1 ; i <= n ; i ++ ) { cin >> a [ i ]; } sort ( a + 1 , a + 1 + n ); int L = 0 , R = a [ n ]; while ( R - L > 1 ) { int mid = ( L + R ) >> 1 ; if ( p ( mid )) { R = mid ; } else { L = mid ; } } cout << R << \" \\n \" ; return 0 ; }","title":"Cfs20221004"},{"location":"match/cfs20221004/#\u6982\u8981","text":"\u539f\u672c\u538b\u7ebf\u6ca1\u6709 U\u76d8~~\uff0c\u4f46\u7531\u4e8e\u4f1f\u5927\u7684 cyy \u82f1\u52c7\u8131\u63a7\uff0c\u6210\u529f\u628a U\u76d8\u8ba9\u7ed9\u4e86\u6211~~\u3002 \u9898\u76ee\u8fd8\u7b97\u7b80\u5355\uff0c\u5c31\u662f\u6709\u70b9\u5c31\u5751\u3002","title":"\u6982\u8981"},{"location":"match/cfs20221004/#\u9898\u76ee","text":"","title":"\u9898\u76ee"},{"location":"match/cfs20221004/#t1","text":"\u5c31\u4e00\u4e2a\u7ed3\u6784\u4f53\u6392\u5e8f\uff0c\u4f46\u662f\u6ce8\u610f \u524d\u9762\u6709 \\(k\\) \u4e2a\u5b66\u751f\u6392\u540d\u6bd4\u4ed6\u9ad8\uff0c\u4e14\u5e74\u7ea7\u6bd4\u4ed6\u4f4e\u3002 \u5373 \u5e73\u5206\u4f46\u5e74\u7ea7\u4f4e\u4e5f\u7b97\u3002 #include <bits/stdc++.h> using namespace std ; int n ; struct node { int s , g ; } a [ 210 ]; bool cmp ( node s1 , node s2 ) { if ( s1 . s == s2 . s ) { return s1 . g < s2 . g ; } return s1 . s > s2 . s ; } int main () { freopen ( \"paiming.in\" , \"r\" , stdin ); freopen ( \"paiming.out\" , \"w\" , stdout ); cin >> n ; for ( int i = 1 ; i <= n ; i ++ ) { cin >> a [ i ]. s >> a [ i ]. g ; } sort ( a + 1 , a + 1 + n , cmp ); for ( int i = 1 ; i <= n ; i ++ ) { int cnt = 0 ; for ( int j = 1 ; j < i ; j ++ ) { if ( a [ j ]. g < a [ i ]. g ) { cnt ++ ; } } cout << cnt << \" \\n \" ; } return 0 ; }","title":"T1"},{"location":"match/cfs20221004/#t2","text":"\\(\\texttt{DFS/BFS}\\) \u6211\u7528\u7684 \\(\\texttt{DFS}\\) \uff0c\u4f46 T \u4e86\u4e00\u4e2a\u70b9\u3002 \u6362\u4e86\u4e00\u79cd\u601d\u8def\u7684 \\(\\texttt{DFS}\\) \uff0c\u5bf9\u4e86\u3002 #include <bits/stdc++.h> using namespace std ; int hill , lake , n , m , mp [ 1010 ][ 1010 ]; bool vis [ 1010 ][ 1010 ], vvis [ 1010 ][ 1010 ], maxn , minn ; const int dx [] = { 114514 , 1 , -1 , 0 , 0 }, dy [] = { 1919810 , 0 , 0 , 1 , -1 }; void dfs ( int z , int x , int y ) { vis [ x ][ y ] = 1 ; for ( int i = 1 ; i <= 4 ; i ++ ) { int nx = x + dx [ i ], ny = y + dy [ i ]; if ( nx < 1 || ny < 1 || nx > n || ny > m || ( vis [ nx ][ ny ] && mp [ nx ][ ny ] == z )) { continue ; } if ( mp [ nx ][ ny ] > z ) { maxn = 1 ; continue ; } if ( mp [ nx ][ ny ] < z ) { minn = 1 ; continue ; } dfs ( mp [ nx ][ ny ], nx , ny ); } } int main () { freopen ( \"seek.in\" , \"r\" , stdin ); freopen ( \"seek.out\" , \"w\" , stdout ); scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { scanf ( \"%d\" , & mp [ i ][ j ]); } } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { if ( vis [ i ][ j ]) { continue ; } maxn = 0 ; minn = 0 ; //memset(vvis,0,sizeof(vvis)); dfs ( mp [ i ][ j ], i , j ); if ( minn && ( ! maxn )) //it is a beautiful mountain { hill ++ ; } if (( ! minn ) && maxn ) //it is a wonderful lake { lake ++ ; } } } cout << lake << \" \" << hill << \" \\n \" ; return 0 ; }","title":"T2"},{"location":"match/cfs20221004/#t3","text":"\u6570\u5b66\u9898 \u679a\u4e3e\u4e24\u70b9\u540e\u9000\u51fa\u7b2c\u4e09\u7b2c\u56db\u70b9\uff0c\u4e0d\u4f1a T\u3002 \u7b97\u9762\u79ef\u5c31\u62c6\u6210 \\(4\\) \u4e2a\u4e09\u89d2 \\(+\\) \\(1\\) \u4e2a\u6b63\u65b9\u5f62\uff08\u8f6c\u659c\u4e3a\u6b63\uff09 \u5177\u4f53\u53ef\u4ee5\u53c2\u8003 chenyuxuan \u5de8\u4f6c\u5199\u7684 click here #include <bits/stdc++.h> using namespace std ; int n , ans ; struct node { int x , y ; } a [ 3010 ]; bitset < 5010 > mp [ 5010 ]; int main () { freopen ( \"ruin.in\" , \"r\" , stdin ); freopen ( \"ruin.out\" , \"w\" , stdout ); cin >> n ; for ( int i = 1 ; i <= n ; i ++ ) { cin >> a [ i ]. x >> a [ i ]. y ; mp [ a [ i ]. x ][ a [ i ]. y ] = 1 ; } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( j == i ) continue ; if ( a [ j ]. x <= a [ i ]. x ) continue ; int dx = a [ j ]. x - a [ i ]. x ; int dy = a [ j ]. y - a [ i ]. y ; int x3 = a [ j ]. x - dy ; int y3 = a [ j ]. y + dx ; int x4 = x3 - dx ; int y4 = y3 - dy ; //cerr<<x3<<\" \"<<y3<<\" - \"<<x4<<\" \"<<y4<<\"\\n\"; if ( x3 > 5000 || x4 > 5000 || x3 < 0 || x4 < 0 || y3 > 5000 || y4 > 5000 || y3 < 0 || y4 < 0 ) { continue ; } if ( mp [ x3 ][ y3 ] && mp [ x4 ][ y4 ]) { ans = max ( ans , abs ( a [ j ]. x - a [ i ]. x ) * abs ( a [ j ]. y - a [ i ]. y ) * 2 + ( min ( a [ j ]. x , x3 ) - max ( a [ i ]. x , x4 )) * ( min ( y3 , y4 ) - max ( a [ i ]. y , a [ j ]. y ))); } } } cout << ans << \" \\n \" ; return 0 ; }","title":"T3"},{"location":"match/cfs20221004/#t4","text":"\u8fde\u73af\u7206\u70b8\u3002 \u4e8c\u5206\u5224\u65ad\u4e2d\u95f4\u76f8\u9694\u8ddd\u79bb\u662f\u5426\u5927\u4e8e \\(mid\\) \u3002 #include <bits/stdc++.h> using namespace std ; int n , k , a [ 50010 ], b [ 50010 ]; bool p ( int x ) { int s = 0 , pos = -2000114514 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( pos + x < a [ i ]) { s ++ ; } pos = a [ i ]; } return ( s <= k ); } int main () { freopen ( \"angry.in\" , \"r\" , stdin ); freopen ( \"angry.out\" , \"w\" , stdout ); cin >> n >> k ; for ( int i = 1 ; i <= n ; i ++ ) { cin >> a [ i ]; } sort ( a + 1 , a + 1 + n ); int L = 0 , R = a [ n ]; while ( R - L > 1 ) { int mid = ( L + R ) >> 1 ; if ( p ( mid )) { R = mid ; } else { L = mid ; } } cout << R << \" \\n \" ; return 0 ; }","title":"T4"},{"location":"match/cfs20221005/","text":"20221005 \u6a21\u62df\u8d5b\u89e3\u9898\u62a5\u544a \u00b6 \u6982\u8981 \u00b6 \u4e0d\u7b97\u96be\uff0c\u4f46\u662f\u7b80\u5355\u6a21\u62df\u6ca1\u5199\u5bf9 \u9898\u76ee \u00b6 T1 \u00b6 PBC\u667a\u5546\u771f\u9ad8\uff0cHE AK IOI \u968f\u4fbf\u6a21\u62df\u4e00\u4e0b\u5c31\u884c\uff0c\u600e\u4e48\u4e5f\u4e0d\u4f1a T\u3002 #include <bits/stdc++.h> using namespace std ; int n , t , x = 1 , y = 1 ; int main () { freopen ( \"test.in\" , \"r\" , stdin ); freopen ( \"test.out\" , \"w\" , stdout ); cin >> n >> t ; for ( int i = 1 ; i <= t ; i ++ ) { y ++ ; if ( y > n ) { x ++ ; y = 1 ; } if ( x > n ) { x = 1 ; y = 1 ; } } cout << x << \" \" << y << \" \\n \" ; return 0 ; } T2 \u00b6 \u8d2a\u5fc3 \u5982\u679c\u8d54\u672c\u5c31\u4e0d\u9009 \u5426\u5219\u6309\u4ee3\u4ef7\u5347\u5e8f\uff0c\u5982\u679c\u5f53\u524d\u9009\u4e0d\u4e86\u5c31\u53ef\u4ee5\u76f4\u63a5 break #include <bits/stdc++.h> #define LL long long using namespace std ; int n ; LL ans ; struct node { LL val , uval , jval ; } a [ 100010 ]; bool cmp ( node s1 , node s2 ) { if ( s1 . jval > 0 && s2 . jval > 0 ) { return s1 . uval < s2 . uval ; } return s1 . jval > s2 . jval ; } int main () { freopen ( \"collect.in\" , \"r\" , stdin ); freopen ( \"collect.out\" , \"w\" , stdout ); scanf ( \"%d%lld\" , & n , & ans ); for ( int i = 1 ; i <= n ; i ++ ) { scanf ( \"%lld%lld\" , & a [ i ]. val , & a [ i ]. uval ); a [ i ]. jval = a [ i ]. val - a [ i ]. uval ; } sort ( a + 1 , a + 1 + n , cmp ); for ( int i = 1 ; i <= n ; i ++ ) { if ( ans < a [ i ]. uval ) { break ; } if ( a [ i ]. jval <= 0 ) { break ; } ans += a [ i ]. jval ; } printf ( \"%lld \\n \" , ans ); return 0 ; } T3 \u00b6 \u6839\u636e\u9898\u610f\u6a21\u62df\u5373\u53ef #include <bits/stdc++.h> using namespace std ; struct node { int id , gz , y ; char work ; string name ; } a [ 30 ]; struct cnode { string name ; int id , gz , y , iid ; char work ; } b [ 30 ]; string tnc , q , master ; int p [ 10 ], cnt = 2 , team_boss_id ; bool cmp1 ( node s1 , node s2 ) { if ( s1 . gz == s2 . gz ) { return s1 . id < s2 . id ; } return s1 . gz < s2 . gz ; } bool cmp2 ( cnode s1 , cnode s2 ) { if ( s1 . iid == team_boss_id ) { return 1 ; } if ( s2 . iid == team_boss_id ) { return 0 ; } if ( s1 . gz == s2 . gz ) { return s1 . id < s2 . id ; } return s1 . gz < s2 . gz ; } int main () { freopen ( \"footballteam.in\" , \"r\" , stdin ); freopen ( \"footballteam.out\" , \"w\" , stdout ); for ( int i = 1 ; i <= 22 ; i ++ ) { cin >> a [ i ]. id >> a [ i ]. name >> a [ i ]. work ; getline ( cin , tnc ); //cerr<<\"READ IS OK\\n\"; int st = 0 , ed = 0 ; for ( int j = 0 ; j < tnc . size ();) { if ( tnc [ j ] == ' ' ) { a [ i ]. y += ( ed - st + 1 ); ed = 0 , st = 0 ; j ++ ; } else if ( tnc [ j ] >= '0' && tnc [ j ] <= '9' ) { st = ( tnc [ j ] -48 ) * 1000 + ( tnc [ ++ j ] -48 ) * 100 + ( tnc [ ++ j ] -48 ) * 10 + ( tnc [ ++ j ] -48 ); j ++ ; } else if ( tnc [ j ] == '-' ) { ed = ( tnc [ ++ j ] -48 ) * 1000 + ( tnc [ ++ j ] -48 ) * 100 + ( tnc [ ++ j ] -48 ) * 10 + ( tnc [ ++ j ] -48 ); j ++ ; } } a [ i ]. y += ( ed - st + 1 ); cerr << ed << \" \" << st << \" \" ; cerr << a [ i ]. y << \" \\n \" ; if ( a [ i ]. work == 'S' ) { a [ i ]. gz = 4 ; } else if ( a [ i ]. work == 'M' ) { a [ i ]. gz = 3 ; } else if ( a [ i ]. work == 'D' ) { a [ i ]. gz = 2 ; } else if ( a [ i ]. work == 'G' ) { a [ i ]. gz = 1 ; } } sort ( a + 1 , a + 1 + 22 , cmp1 ); cin >> q ; for ( int i = 0 ; i < q . size (); i ++ ) { if ( q [ i ] == '-' ) { cnt ++ ; } else { p [ cnt ] = p [ cnt ] * 10 + ( q [ i ] -48 ); } } cnt = 0 ; p [ 1 ] = 1 ; b [ 0 ]. id = 0 ; b [ 0 ]. y = 0 ; for ( int i = 1 ; i <= 22 ; i ++ ) { if ( p [ a [ i ]. gz ] > 0 ) { b [ ++ cnt ]. id = a [ i ]. id ; b [ cnt ]. iid = cnt ; b [ cnt ]. name = a [ i ]. name ; b [ cnt ]. work = a [ i ]. work ; b [ cnt ]. gz = a [ i ]. gz ; b [ cnt ]. y = a [ i ]. y ; if ( b [ team_boss_id ]. y < b [ cnt ]. y || ( b [ team_boss_id ]. y <= b [ cnt ]. y && b [ cnt ]. id > b [ team_boss_id ]. id )) { team_boss_id = cnt ; } p [ a [ i ]. gz ] -- ; } } if ( cnt != 11 ) { //cerr<<\"CNT=\"<<cnt<<\"\\n\"; puts ( \"IMPOSSIBLE TO ARRANGE\" ); return 0 ; } sort ( b + 1 , b + 1 + cnt , cmp2 ); for ( int i = 1 ; i <= cnt ; i ++ ) { cout << b [ i ]. id << \" \" << b [ i ]. name << \" \" << b [ i ]. work << \" \\n \" ; } return 0 ; } T4 \u00b6 \u6b64\u4e3a \\(\\texttt{DP}\\) \u4e5f\uff0c\u53ef\u662f\u6211\u4e0d\u4f1a\u3002 \u7528\u8d2a\u5fc3\u4e5f\u80fd\u8fc7\u3002 \u89c2\u5bdf\u53d1\u73b0\u65e0\u975e\u5c31\u662f \u5c0f-\u5927-\u5c0f-\u5927\u2026\u2026 \u6216 \u5927-\u5c0f-\u5927-\u5c0f\uff08\u76f8\u6bd4\u4e8e\u76f8\u90bb\u7684\uff09 \u5982\u679c\u4e0d\u7b26\u5408\u5c31\u7d2f\u52a0\u5e76\u4fee\u6539\u4e3a\u6781\u503c #include <bits/stdc++.h> #define TBH 2147483646 #define small 1 #define big 2 using namespace std ; int ans , a [ 100010 ], n , b [ 100010 ]; int c1 () { int cnt = 0 ; a [ n + 1 ] = -1919810 ; for ( int i = 2 ; i <= n ; i += 2 ) { if ( a [ i ] <= a [ i + 1 ] && a [ i ] <= a [ i -1 ]) { cnt ++ ; a [ i ] = TBH ; } else if ( a [ i ] <= a [ i + 1 ]) { cnt ++ ; a [ i + 1 ] = -114514 ; } else if ( a [ i ] <= a [ i -1 ]) { cnt ++ ; a [ i -1 ] = -114514 ; } } return cnt ; } int c2 () { int cnt = 0 ; a [ n + 1 ] = 2147483647 ; for ( int i = 2 ; i <= n ; i += 2 ) { if ( a [ i ] >= a [ i + 1 ] && a [ i ] >= a [ i -1 ]) { cnt ++ ; a [ i ] = -114514 ; } else if ( a [ i ] >= a [ i + 1 ]) { cnt ++ ; a [ i + 1 ] = TBH ; } else if ( a [ i ] >= a [ i -1 ]) { cnt ++ ; a [ i -1 ] = TBH ; } } return cnt ; } int main () { freopen ( \"wave.in\" , \"r\" , stdin ); freopen ( \"wave.out\" , \"w\" , stdout ); cin >> n ; for ( int i = 1 ; i <= n ; i ++ ) { cin >> a [ i ]; b [ i ] = a [ i ]; } if ( n <= 2 ) { puts ( \"0\" ); return 0 ; } if ( n == 3 ) { if (( a [ 2 ] > a [ 3 ] && a [ 2 ] > a [ 1 ]) || ( a [ 2 ] < a [ 3 ] && a [ 2 ] < a [ 1 ])) { puts ( \"0\" ); } puts ( \"1\" ); return 0 ; } int a1 = c1 (); for ( int i = 1 ; i <= n ; i ++ ) { a [ i ] = b [ i ]; } int a2 = c2 (); ans = min ( a1 , a2 ); cout << ans << \" \\n \" ; return 0 ; }","title":"20221005 \u6a21\u62df\u8d5b\u89e3\u9898\u62a5\u544a"},{"location":"match/cfs20221005/#20221005-\u6a21\u62df\u8d5b\u89e3\u9898\u62a5\u544a","text":"","title":"20221005 \u6a21\u62df\u8d5b\u89e3\u9898\u62a5\u544a"},{"location":"match/cfs20221005/#\u6982\u8981","text":"\u4e0d\u7b97\u96be\uff0c\u4f46\u662f\u7b80\u5355\u6a21\u62df\u6ca1\u5199\u5bf9","title":"\u6982\u8981"},{"location":"match/cfs20221005/#\u9898\u76ee","text":"","title":"\u9898\u76ee"},{"location":"match/cfs20221005/#t1","text":"PBC\u667a\u5546\u771f\u9ad8\uff0cHE AK IOI \u968f\u4fbf\u6a21\u62df\u4e00\u4e0b\u5c31\u884c\uff0c\u600e\u4e48\u4e5f\u4e0d\u4f1a T\u3002 #include <bits/stdc++.h> using namespace std ; int n , t , x = 1 , y = 1 ; int main () { freopen ( \"test.in\" , \"r\" , stdin ); freopen ( \"test.out\" , \"w\" , stdout ); cin >> n >> t ; for ( int i = 1 ; i <= t ; i ++ ) { y ++ ; if ( y > n ) { x ++ ; y = 1 ; } if ( x > n ) { x = 1 ; y = 1 ; } } cout << x << \" \" << y << \" \\n \" ; return 0 ; }","title":"T1"},{"location":"match/cfs20221005/#t2","text":"\u8d2a\u5fc3 \u5982\u679c\u8d54\u672c\u5c31\u4e0d\u9009 \u5426\u5219\u6309\u4ee3\u4ef7\u5347\u5e8f\uff0c\u5982\u679c\u5f53\u524d\u9009\u4e0d\u4e86\u5c31\u53ef\u4ee5\u76f4\u63a5 break #include <bits/stdc++.h> #define LL long long using namespace std ; int n ; LL ans ; struct node { LL val , uval , jval ; } a [ 100010 ]; bool cmp ( node s1 , node s2 ) { if ( s1 . jval > 0 && s2 . jval > 0 ) { return s1 . uval < s2 . uval ; } return s1 . jval > s2 . jval ; } int main () { freopen ( \"collect.in\" , \"r\" , stdin ); freopen ( \"collect.out\" , \"w\" , stdout ); scanf ( \"%d%lld\" , & n , & ans ); for ( int i = 1 ; i <= n ; i ++ ) { scanf ( \"%lld%lld\" , & a [ i ]. val , & a [ i ]. uval ); a [ i ]. jval = a [ i ]. val - a [ i ]. uval ; } sort ( a + 1 , a + 1 + n , cmp ); for ( int i = 1 ; i <= n ; i ++ ) { if ( ans < a [ i ]. uval ) { break ; } if ( a [ i ]. jval <= 0 ) { break ; } ans += a [ i ]. jval ; } printf ( \"%lld \\n \" , ans ); return 0 ; }","title":"T2"},{"location":"match/cfs20221005/#t3","text":"\u6839\u636e\u9898\u610f\u6a21\u62df\u5373\u53ef #include <bits/stdc++.h> using namespace std ; struct node { int id , gz , y ; char work ; string name ; } a [ 30 ]; struct cnode { string name ; int id , gz , y , iid ; char work ; } b [ 30 ]; string tnc , q , master ; int p [ 10 ], cnt = 2 , team_boss_id ; bool cmp1 ( node s1 , node s2 ) { if ( s1 . gz == s2 . gz ) { return s1 . id < s2 . id ; } return s1 . gz < s2 . gz ; } bool cmp2 ( cnode s1 , cnode s2 ) { if ( s1 . iid == team_boss_id ) { return 1 ; } if ( s2 . iid == team_boss_id ) { return 0 ; } if ( s1 . gz == s2 . gz ) { return s1 . id < s2 . id ; } return s1 . gz < s2 . gz ; } int main () { freopen ( \"footballteam.in\" , \"r\" , stdin ); freopen ( \"footballteam.out\" , \"w\" , stdout ); for ( int i = 1 ; i <= 22 ; i ++ ) { cin >> a [ i ]. id >> a [ i ]. name >> a [ i ]. work ; getline ( cin , tnc ); //cerr<<\"READ IS OK\\n\"; int st = 0 , ed = 0 ; for ( int j = 0 ; j < tnc . size ();) { if ( tnc [ j ] == ' ' ) { a [ i ]. y += ( ed - st + 1 ); ed = 0 , st = 0 ; j ++ ; } else if ( tnc [ j ] >= '0' && tnc [ j ] <= '9' ) { st = ( tnc [ j ] -48 ) * 1000 + ( tnc [ ++ j ] -48 ) * 100 + ( tnc [ ++ j ] -48 ) * 10 + ( tnc [ ++ j ] -48 ); j ++ ; } else if ( tnc [ j ] == '-' ) { ed = ( tnc [ ++ j ] -48 ) * 1000 + ( tnc [ ++ j ] -48 ) * 100 + ( tnc [ ++ j ] -48 ) * 10 + ( tnc [ ++ j ] -48 ); j ++ ; } } a [ i ]. y += ( ed - st + 1 ); cerr << ed << \" \" << st << \" \" ; cerr << a [ i ]. y << \" \\n \" ; if ( a [ i ]. work == 'S' ) { a [ i ]. gz = 4 ; } else if ( a [ i ]. work == 'M' ) { a [ i ]. gz = 3 ; } else if ( a [ i ]. work == 'D' ) { a [ i ]. gz = 2 ; } else if ( a [ i ]. work == 'G' ) { a [ i ]. gz = 1 ; } } sort ( a + 1 , a + 1 + 22 , cmp1 ); cin >> q ; for ( int i = 0 ; i < q . size (); i ++ ) { if ( q [ i ] == '-' ) { cnt ++ ; } else { p [ cnt ] = p [ cnt ] * 10 + ( q [ i ] -48 ); } } cnt = 0 ; p [ 1 ] = 1 ; b [ 0 ]. id = 0 ; b [ 0 ]. y = 0 ; for ( int i = 1 ; i <= 22 ; i ++ ) { if ( p [ a [ i ]. gz ] > 0 ) { b [ ++ cnt ]. id = a [ i ]. id ; b [ cnt ]. iid = cnt ; b [ cnt ]. name = a [ i ]. name ; b [ cnt ]. work = a [ i ]. work ; b [ cnt ]. gz = a [ i ]. gz ; b [ cnt ]. y = a [ i ]. y ; if ( b [ team_boss_id ]. y < b [ cnt ]. y || ( b [ team_boss_id ]. y <= b [ cnt ]. y && b [ cnt ]. id > b [ team_boss_id ]. id )) { team_boss_id = cnt ; } p [ a [ i ]. gz ] -- ; } } if ( cnt != 11 ) { //cerr<<\"CNT=\"<<cnt<<\"\\n\"; puts ( \"IMPOSSIBLE TO ARRANGE\" ); return 0 ; } sort ( b + 1 , b + 1 + cnt , cmp2 ); for ( int i = 1 ; i <= cnt ; i ++ ) { cout << b [ i ]. id << \" \" << b [ i ]. name << \" \" << b [ i ]. work << \" \\n \" ; } return 0 ; }","title":"T3"},{"location":"match/cfs20221005/#t4","text":"\u6b64\u4e3a \\(\\texttt{DP}\\) \u4e5f\uff0c\u53ef\u662f\u6211\u4e0d\u4f1a\u3002 \u7528\u8d2a\u5fc3\u4e5f\u80fd\u8fc7\u3002 \u89c2\u5bdf\u53d1\u73b0\u65e0\u975e\u5c31\u662f \u5c0f-\u5927-\u5c0f-\u5927\u2026\u2026 \u6216 \u5927-\u5c0f-\u5927-\u5c0f\uff08\u76f8\u6bd4\u4e8e\u76f8\u90bb\u7684\uff09 \u5982\u679c\u4e0d\u7b26\u5408\u5c31\u7d2f\u52a0\u5e76\u4fee\u6539\u4e3a\u6781\u503c #include <bits/stdc++.h> #define TBH 2147483646 #define small 1 #define big 2 using namespace std ; int ans , a [ 100010 ], n , b [ 100010 ]; int c1 () { int cnt = 0 ; a [ n + 1 ] = -1919810 ; for ( int i = 2 ; i <= n ; i += 2 ) { if ( a [ i ] <= a [ i + 1 ] && a [ i ] <= a [ i -1 ]) { cnt ++ ; a [ i ] = TBH ; } else if ( a [ i ] <= a [ i + 1 ]) { cnt ++ ; a [ i + 1 ] = -114514 ; } else if ( a [ i ] <= a [ i -1 ]) { cnt ++ ; a [ i -1 ] = -114514 ; } } return cnt ; } int c2 () { int cnt = 0 ; a [ n + 1 ] = 2147483647 ; for ( int i = 2 ; i <= n ; i += 2 ) { if ( a [ i ] >= a [ i + 1 ] && a [ i ] >= a [ i -1 ]) { cnt ++ ; a [ i ] = -114514 ; } else if ( a [ i ] >= a [ i + 1 ]) { cnt ++ ; a [ i + 1 ] = TBH ; } else if ( a [ i ] >= a [ i -1 ]) { cnt ++ ; a [ i -1 ] = TBH ; } } return cnt ; } int main () { freopen ( \"wave.in\" , \"r\" , stdin ); freopen ( \"wave.out\" , \"w\" , stdout ); cin >> n ; for ( int i = 1 ; i <= n ; i ++ ) { cin >> a [ i ]; b [ i ] = a [ i ]; } if ( n <= 2 ) { puts ( \"0\" ); return 0 ; } if ( n == 3 ) { if (( a [ 2 ] > a [ 3 ] && a [ 2 ] > a [ 1 ]) || ( a [ 2 ] < a [ 3 ] && a [ 2 ] < a [ 1 ])) { puts ( \"0\" ); } puts ( \"1\" ); return 0 ; } int a1 = c1 (); for ( int i = 1 ; i <= n ; i ++ ) { a [ i ] = b [ i ]; } int a2 = c2 (); ans = min ( a1 , a2 ); cout << ans << \" \\n \" ; return 0 ; }","title":"T4"},{"location":"match/cfs20221006/","text":"20221006J \u6a21\u62df\u8d5b\u89e3\u9898\u62a5\u544a \u00b6 \u6982\u8981 \u00b6 \u9898\u76ee\u5f88\u7b80\u5355\u3002 T3 \u538b\u4f4d\u6ca1\u5f00 \\(\\texttt{LL}\\) \u75db\u5931 \\(70pts\\) \u75db\u5931 U \u76d8 \u9898\u76ee \u00b6 T1 \u00b6 \u5927\u6c34\u9898\uff0c\u76f4\u63a5\u6839\u636e\u9898\u610f\u63cf\u8ff0\u5373\u53ef #include<bits/stdc++.h> using namespace std; string s; int ss,ff,mm; void f(int x) { if(x<10) { cout<<\"0\"<<x; } else cout<<x; } int main() { freopen(\"clock.in\",\"r\",stdin); freopen(\"clock.out\",\"w\",stdout); cin>>s; ss=(s[0]-48)*10+(s[1]-48); ff=(s[3]-48)*10+(s[4]-48); mm=(s[6]-48)*10+(s[7]-48); mm++; if(mm==60) { ff++; mm=0; } if(ff==60) { ss++; ff=0; } if(ss==24) { ss=0; } f(ss); cout<<\":\"; f(ff); cout<<\":\"; f(mm); cout<<\"\\n\"; return 0; } T2 \u00b6 \\(\\texttt{DFS}\\) \u5c31\u53ef\u4ee5\u8fc7 \u8001Q\u673a\u5b50\u592a\u5feb\u4e86 \u5982\u679c\u6709\u66f4\u597d\u65b9\u6cd5\u8bf7\u63d0\u51fa #include <bits/stdc++.h> using namespace std ; int n , a [ 10 ], b [ 10 ], ans = 19198100 ; bool visi [ 10 ], visj [ 10 ]; void dfs ( int depth , int s , int cnt ) { if ( depth > n ) { ans = min ( ans , cnt ); return ; } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { int tnc = max ( cnt , abs ( s + a [ i ] * b [ j ])); if ( ! visi [ i ] && ! visj [ j ] && tnc < ans ) { visi [ i ] = 1 ; visj [ j ] = 1 ; dfs ( depth + 1 , s + a [ i ] * b [ j ], tnc ); visi [ i ] = 0 ; visj [ j ] = 0 ; } } } return ; } int main () { freopen ( \"hanger.in\" , \"r\" , stdin ); freopen ( \"hanger.out\" , \"w\" , stdout ); cin >> n ; for ( int i = 1 ; i <= n ; i ++ ) { cin >> a [ i ]; } for ( int i = 1 ; i <= n ; i ++ ) { cin >> b [ i ]; } dfs ( 1 , 0 , 0 ); cout << ans << \" \\n \" ; return 0 ; } T3 \u00b6 \u76f4\u63a5 \\(l\\) \u679a\u4e3e\u5230 \\(r\\) \u5e76 \\(\\texttt{checker}\\) \u4e00\u4e0b\u5373\u53ef #include <bits/stdc++.h> #define int long long using namespace std ; int l , r , ans ; int power [] = { 1 , 10 , 100 , 1000 , 10000 , 100000 , 1000000 , 10000000 , 100000000 , 1000000000 }; int checker ( int x ) { int y = 0 ; while ( x ) { y += ( power [ x % 10 ]); x /= 10 ; } for ( int i = 0 ; i <= 9 ; i ++ ) { if ( y / power [ i ] % 10 % 2 ) { return 0 ; } } return 1 ; } int main () { freopen ( \"digits.in\" , \"r\" , stdin ); freopen ( \"digits.out\" , \"w\" , stdout ); cin >> l >> r ; for ( int i = l ; i <= r ; i ++ ) { ans += checker ( i ); } cout << ans << \" \\n \" ; return 0 ; } T4 \u00b6 \u5b57\u7b26\u4e32\u5904\u7406 \\(+\\) \u7c7b\u4f3c\u6590\u6ce2\u90a3\u5951\u6570\u5217\uff08\u9012\u63a8\u9884\u5904\u7406\u4e00\u4e0b\uff09 \u5982\u679c\u6709 m \u6216 w \u5219\u4e0d\u5b58\u5728 #include <bits/stdc++.h> #define LL long long using namespace std ; const LL MOD = 1e9 + 7 ; struct node { int num ; char val ; } a ; LL Fib [ 100010 ], ans = 1 ; int S ; string s ; bool flag = 0 ; int main () { freopen ( \"note.in\" , \"r\" , stdin ); freopen ( \"note.out\" , \"w\" , stdout ); cin >> s ; S = s . size (); a . val = 'A' ; Fib [ 0 ] = 1 ; Fib [ 1 ] = 1 ; Fib [ 2 ] = 2 ; for ( int i = 3 ; i <= S ; i ++ ) { Fib [ i ] = ( Fib [ i -1 ] + Fib [ i -2 ]) % MOD ; } for ( int i = 0 ; i < S ; i ++ ) { if ( s [ i ] == 'n' ) { if ( a . val == 'n' ) { a . num ++ ; } else { ans = ans * Fib [ a . num ] % MOD ; a . val = 'n' ; a . num = 1 ; } } else if ( s [ i ] == 'u' ) { if ( a . val == 'u' ) { a . num ++ ; } else { ans = ans * Fib [ a . num ] % MOD ; a . val = 'u' ; a . num = 1 ; } } else if ( s [ i ] == 'w' || s [ i ] == 'm' ) { flag = 1 ; break ; } else { ans = ans * Fib [ a . num ] % MOD ; a . val = 'A' ; a . num = 0 ; } } ans = ans * Fib [ a . num ] % MOD ; if ( flag ) ans = 0 ; cout << ans << \" \\n \" ; return 0 ; }","title":"20221006J \u6a21\u62df\u8d5b\u89e3\u9898\u62a5\u544a"},{"location":"match/cfs20221006/#20221006j-\u6a21\u62df\u8d5b\u89e3\u9898\u62a5\u544a","text":"","title":"20221006J \u6a21\u62df\u8d5b\u89e3\u9898\u62a5\u544a"},{"location":"match/cfs20221006/#\u6982\u8981","text":"\u9898\u76ee\u5f88\u7b80\u5355\u3002 T3 \u538b\u4f4d\u6ca1\u5f00 \\(\\texttt{LL}\\) \u75db\u5931 \\(70pts\\) \u75db\u5931 U \u76d8","title":"\u6982\u8981"},{"location":"match/cfs20221006/#\u9898\u76ee","text":"","title":"\u9898\u76ee"},{"location":"match/cfs20221006/#t1","text":"\u5927\u6c34\u9898\uff0c\u76f4\u63a5\u6839\u636e\u9898\u610f\u63cf\u8ff0\u5373\u53ef #include<bits/stdc++.h> using namespace std; string s; int ss,ff,mm; void f(int x) { if(x<10) { cout<<\"0\"<<x; } else cout<<x; } int main() { freopen(\"clock.in\",\"r\",stdin); freopen(\"clock.out\",\"w\",stdout); cin>>s; ss=(s[0]-48)*10+(s[1]-48); ff=(s[3]-48)*10+(s[4]-48); mm=(s[6]-48)*10+(s[7]-48); mm++; if(mm==60) { ff++; mm=0; } if(ff==60) { ss++; ff=0; } if(ss==24) { ss=0; } f(ss); cout<<\":\"; f(ff); cout<<\":\"; f(mm); cout<<\"\\n\"; return 0; }","title":"T1"},{"location":"match/cfs20221006/#t2","text":"\\(\\texttt{DFS}\\) \u5c31\u53ef\u4ee5\u8fc7 \u8001Q\u673a\u5b50\u592a\u5feb\u4e86 \u5982\u679c\u6709\u66f4\u597d\u65b9\u6cd5\u8bf7\u63d0\u51fa #include <bits/stdc++.h> using namespace std ; int n , a [ 10 ], b [ 10 ], ans = 19198100 ; bool visi [ 10 ], visj [ 10 ]; void dfs ( int depth , int s , int cnt ) { if ( depth > n ) { ans = min ( ans , cnt ); return ; } for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { int tnc = max ( cnt , abs ( s + a [ i ] * b [ j ])); if ( ! visi [ i ] && ! visj [ j ] && tnc < ans ) { visi [ i ] = 1 ; visj [ j ] = 1 ; dfs ( depth + 1 , s + a [ i ] * b [ j ], tnc ); visi [ i ] = 0 ; visj [ j ] = 0 ; } } } return ; } int main () { freopen ( \"hanger.in\" , \"r\" , stdin ); freopen ( \"hanger.out\" , \"w\" , stdout ); cin >> n ; for ( int i = 1 ; i <= n ; i ++ ) { cin >> a [ i ]; } for ( int i = 1 ; i <= n ; i ++ ) { cin >> b [ i ]; } dfs ( 1 , 0 , 0 ); cout << ans << \" \\n \" ; return 0 ; }","title":"T2"},{"location":"match/cfs20221006/#t3","text":"\u76f4\u63a5 \\(l\\) \u679a\u4e3e\u5230 \\(r\\) \u5e76 \\(\\texttt{checker}\\) \u4e00\u4e0b\u5373\u53ef #include <bits/stdc++.h> #define int long long using namespace std ; int l , r , ans ; int power [] = { 1 , 10 , 100 , 1000 , 10000 , 100000 , 1000000 , 10000000 , 100000000 , 1000000000 }; int checker ( int x ) { int y = 0 ; while ( x ) { y += ( power [ x % 10 ]); x /= 10 ; } for ( int i = 0 ; i <= 9 ; i ++ ) { if ( y / power [ i ] % 10 % 2 ) { return 0 ; } } return 1 ; } int main () { freopen ( \"digits.in\" , \"r\" , stdin ); freopen ( \"digits.out\" , \"w\" , stdout ); cin >> l >> r ; for ( int i = l ; i <= r ; i ++ ) { ans += checker ( i ); } cout << ans << \" \\n \" ; return 0 ; }","title":"T3"},{"location":"match/cfs20221006/#t4","text":"\u5b57\u7b26\u4e32\u5904\u7406 \\(+\\) \u7c7b\u4f3c\u6590\u6ce2\u90a3\u5951\u6570\u5217\uff08\u9012\u63a8\u9884\u5904\u7406\u4e00\u4e0b\uff09 \u5982\u679c\u6709 m \u6216 w \u5219\u4e0d\u5b58\u5728 #include <bits/stdc++.h> #define LL long long using namespace std ; const LL MOD = 1e9 + 7 ; struct node { int num ; char val ; } a ; LL Fib [ 100010 ], ans = 1 ; int S ; string s ; bool flag = 0 ; int main () { freopen ( \"note.in\" , \"r\" , stdin ); freopen ( \"note.out\" , \"w\" , stdout ); cin >> s ; S = s . size (); a . val = 'A' ; Fib [ 0 ] = 1 ; Fib [ 1 ] = 1 ; Fib [ 2 ] = 2 ; for ( int i = 3 ; i <= S ; i ++ ) { Fib [ i ] = ( Fib [ i -1 ] + Fib [ i -2 ]) % MOD ; } for ( int i = 0 ; i < S ; i ++ ) { if ( s [ i ] == 'n' ) { if ( a . val == 'n' ) { a . num ++ ; } else { ans = ans * Fib [ a . num ] % MOD ; a . val = 'n' ; a . num = 1 ; } } else if ( s [ i ] == 'u' ) { if ( a . val == 'u' ) { a . num ++ ; } else { ans = ans * Fib [ a . num ] % MOD ; a . val = 'u' ; a . num = 1 ; } } else if ( s [ i ] == 'w' || s [ i ] == 'm' ) { flag = 1 ; break ; } else { ans = ans * Fib [ a . num ] % MOD ; a . val = 'A' ; a . num = 0 ; } } ans = ans * Fib [ a . num ] % MOD ; if ( flag ) ans = 0 ; cout << ans << \" \\n \" ; return 0 ; }","title":"T4"},{"location":"match/csp2022/","text":"CSP2022 \u9065\u6709\u6b64\u5bc4 \u00b6 \u603b\u8ff0 \u00b6 \u8fd9\u6b21\u9898\u76ee\u9664\u4e86 T3 \u90fd\u8fd8\u884c \u4f46\u662f\u2026\u2026 I LOVE CCF! T1 \u00b6 \u505a\u6cd5 \u00b6 \u5f88\u7b80\u5355\uff0c\u66b4\u529b\u4e00\u4e0b\uff0c\u5927\u4e8e \\(10^9\\) \u9000\u51fa\u5373\u53ef\u3002 srds\uff0cI use the kasumi \u65f6\u95f4\u82b1\u8d39\u6709 ~\u4ebf ~\u70b9\u591a\u3002 JYL \u7528 pow \u90fd\u80fd\u5bf9 \u4ee3\u7801(pow.cpp) \u00b6 #include <bits/stdc++.h> #define LL long long using namespace std ; const LL MOD = ( 1e9 ); LL a , b ; LL kasumi ( LL a , LL b ) { LL ans = 1 , cnt = a ; while ( b ) { if ( cnt > MOD ) { return -1 ; } if ( b & 1 ) { ans = ans * cnt ; if ( ans > MOD ) { return -1 ; } } cnt = cnt * cnt ; b >>= 1 ; } return ans ; } int main () { freopen ( \"pow.in\" , \"r\" , stdin ); freopen ( \"pow.out\" , \"w\" , stdout ); cin >> a >> b ; cout << kasumi ( a , b ) << \" \\n \" ; return 0 ; } T2 \u00b6 \u505a\u6cd5 \u00b6 \u53d8\u5f62\u540e\u53d1\u73b0\u662f\u4e8c\u5206\u3002 \u2235 \u548c\u56fe\u5f62\u5927\u5c0f\u539f\u7406\u5dee\u4e0d\u591a \u2234 \u5f53\u5728 \\(p=q\\) \u540e\uff0c\u5c31\u4f1a\u8d8b\u52bf\u7531\u5927\u53d8\u5c0f \u2234 \u662f\u53cc\u5cf0\uff0c\u8981 \\(+1 \\div 2\\) \u2234 \u592a\u68d2\u4e86!\u6211\u7231 CCF! r=ppq+1>>1 -> r=ppq \\(\\texttt{100pts}\\) -> \\(\\texttt{0pt}\\) \u5316\u7b80\u540e\u53d1\u73b0 \\(p + q = n + 2 - e \\times d\\) \u4e8c\u5206\u8fd9\u4e2a\u5373\u53ef\uff0c\u5224\u65ad\u662f\u5426 \\(= n\\) \u4ee3\u7801(decode.cpp) \u00b6 #include <bits/stdc++.h> #define LL long long using namespace std ; int k ; void work () { LL n , e , d , ppq , pq ; scanf ( \"%lld%lld%lld\" , & n , & e , & d ); ppq = n + 2 - e * d ; pq = n ; LL l = 0 , r = ppq + 1 >> 1 ; while ( l < r ) { LL mid = ( l + r ) >> 1 ; if ( mid * ( ppq - mid ) < pq ) { l = mid + 1 ; } else r = mid ; } if ( l * ( ppq - l ) == pq && l <= ( ppq - l )) { printf ( \"%lld %lld \\n \" , l , ppq - l ); return ; } puts ( \"NO\" ); return ; } int main () { freopen ( \"decode.in\" , \"r\" , stdin ); freopen ( \"decode.out\" , \"w\" , stdout ); scanf ( \"%d\" , & k ); while ( k -- ) { work (); } return 0 ; } T3 \u00b6 \u5927\u6a21\u62df\uff0c\u4e07\u6076\u4e4b\u6e90 \u9a97\u4e86 \\(\\texttt{40pts}\\) \u4f46\u662f\u82b1\u4e86 \\(\\texttt{2h+}\\) \u5341\u5206\u4e0d\u5212\u7b97 \u5bfc\u81f4 T2\u3001T4 \u6302\u4e86 \u505a\u6cd5 \u00b6 \u6211\u4e0d\u77e5\u9053 \u4ee3\u7801(expr.cpp) \u00b6 \u6211\u66f4\u4e0d\u4f1a pr\u6211\u7231\u4f60 T4 \u00b6 \u4e00\u4e2a\u52a8\u6001\u7f16\u7a0b\u9898\uff0c\u4f46\u6211\u53ea\u60f3\u5230 \\(\\texttt{60pts}\\) \u7684\u52a8\u6001\u7f16\u7a0b\u505a\u6cd5 \u505a\u6cd5 \u00b6 \u8bbe \\(\\texttt{dp[i][k]}\\) \u4e3a\u5f53\u524d\u4e3a\u7b2c \\(i\\) \u4e2a\u70b9\uff0c\u7528\u4e86\u989d\u5916\u7684 \\(k\\) \u4e2a \u5916\u6302 \u6574\u70b9\u3002 \\(\\texttt{dp[i][k]} = \\max \\{\\texttt{dp[j][k-d]}\\}\\) ( \\(1 \\le j < i\\) \uff0c \\(d\\) \u4e3a\u4e24\u70b9\u95f4\u9700\u8981\u7528\u5230\u7684\u989d\u5916\u7684 \u5916\u6302 \u6574\u70b9) \u521d\u59cb\u65f6 \\(\\texttt{dp[i][k]}=1\\) \\(\\texttt{DP}\\) \u524d\u8981\u6392\u5e8f\uff0c\u5c31\u662f\u628a\u4e24\u4e2a\u70b9\uff0c\u5982\u679c \\(s1\\) \u80fd\u6401\u5230 \\(s2\\) \u5c31\u4e0d\u7528\u53d8\uff0c\u4e5f\u5c31\u662f \\(s1.x+s1.y<s2.x+s2.y\\) \u4ee3\u7801(point.cpp) \u00b6 #include <bits/stdc++.h> using namespace std ; int ans , n , kk , f [ 510 ][ 110 ]; struct node { int x , y ; } a [ 510 ]; bool cmp ( node s1 , node s2 ) { return ( s1 . x + s1 . y ) < ( s2 . x + s2 . y ); } int main () { freopen ( \"point.in\" , \"r\" , stdin ); freopen ( \"point.out\" , \"w\" , stdout ); scanf ( \"%d%d\" , & n , & kk ); for ( int i = 1 ; i <= n ; i ++ ) { scanf ( \"%d%d\" , & a [ i ]. x , & a [ i ]. y ); } sort ( a + 1 , a + 1 + n , cmp ); for ( int i = 1 ; i <= n ; i ++ ) { for ( int k = 0 ; k <= kk ; k ++ ) { f [ i ][ k ] = 1 ; for ( int j = 1 ; j < i ; j ++ ) { if ( a [ i ]. x < a [ j ]. x || a [ i ]. y < a [ j ]. y ) continue ; int d = ( a [ i ]. x - a [ j ]. x ) + ( a [ i ]. y - a [ j ]. y ) -1 ; if ( k >= d ) { f [ i ][ k ] = max ( f [ i ][ k ], f [ j ][ k - d ] + d + 1 ); } } ans = max ( f [ i ][ k ] + ( kk - k ), ans ); } } printf ( \"%d \\n \" , ans ); return 0 ; } \u603b\u7ed3 \u00b6 \u8fd9\u6b21\u6bd4\u8d5b\u51fa\u4e86\u4ebf\u70b9\u70b9\u5927\u5931\u8bef\uff0c\u5f53\u521d\u5e94\u8be5 \\(\\texttt{T1->T2->T4}\\) \u7136\u540e\u68c0\u67e5\uff0c\u518d\u8c61\u5f81\u6027\u5730\u9a97\u70b9 \\(\\texttt{T3}\\) \u7684\u5206\u3002 \u6211\u7231 CCF \u8d5e\u7f8e\u592a\u9633! \u5bc4! \u5e0c\u671b\u660e\u5e74\u53ef\u4ee5 RP++ \\(\\texttt{lzx's 2022 Round}\\) END","title":"CSP2022"},{"location":"match/csp2022/#csp2022-\u9065\u6709\u6b64\u5bc4","text":"","title":"CSP2022 \u9065\u6709\u6b64\u5bc4"},{"location":"match/csp2022/#\u603b\u8ff0","text":"\u8fd9\u6b21\u9898\u76ee\u9664\u4e86 T3 \u90fd\u8fd8\u884c \u4f46\u662f\u2026\u2026 I LOVE CCF!","title":"\u603b\u8ff0"},{"location":"match/csp2022/#t1","text":"","title":"T1"},{"location":"match/csp2022/#\u505a\u6cd5","text":"\u5f88\u7b80\u5355\uff0c\u66b4\u529b\u4e00\u4e0b\uff0c\u5927\u4e8e \\(10^9\\) \u9000\u51fa\u5373\u53ef\u3002 srds\uff0cI use the kasumi \u65f6\u95f4\u82b1\u8d39\u6709 ~\u4ebf ~\u70b9\u591a\u3002 JYL \u7528 pow \u90fd\u80fd\u5bf9","title":"\u505a\u6cd5"},{"location":"match/csp2022/#\u4ee3\u7801powcpp","text":"#include <bits/stdc++.h> #define LL long long using namespace std ; const LL MOD = ( 1e9 ); LL a , b ; LL kasumi ( LL a , LL b ) { LL ans = 1 , cnt = a ; while ( b ) { if ( cnt > MOD ) { return -1 ; } if ( b & 1 ) { ans = ans * cnt ; if ( ans > MOD ) { return -1 ; } } cnt = cnt * cnt ; b >>= 1 ; } return ans ; } int main () { freopen ( \"pow.in\" , \"r\" , stdin ); freopen ( \"pow.out\" , \"w\" , stdout ); cin >> a >> b ; cout << kasumi ( a , b ) << \" \\n \" ; return 0 ; }","title":"\u4ee3\u7801(pow.cpp)"},{"location":"match/csp2022/#t2","text":"","title":"T2"},{"location":"match/csp2022/#\u505a\u6cd5_1","text":"\u53d8\u5f62\u540e\u53d1\u73b0\u662f\u4e8c\u5206\u3002 \u2235 \u548c\u56fe\u5f62\u5927\u5c0f\u539f\u7406\u5dee\u4e0d\u591a \u2234 \u5f53\u5728 \\(p=q\\) \u540e\uff0c\u5c31\u4f1a\u8d8b\u52bf\u7531\u5927\u53d8\u5c0f \u2234 \u662f\u53cc\u5cf0\uff0c\u8981 \\(+1 \\div 2\\) \u2234 \u592a\u68d2\u4e86!\u6211\u7231 CCF! r=ppq+1>>1 -> r=ppq \\(\\texttt{100pts}\\) -> \\(\\texttt{0pt}\\) \u5316\u7b80\u540e\u53d1\u73b0 \\(p + q = n + 2 - e \\times d\\) \u4e8c\u5206\u8fd9\u4e2a\u5373\u53ef\uff0c\u5224\u65ad\u662f\u5426 \\(= n\\)","title":"\u505a\u6cd5"},{"location":"match/csp2022/#\u4ee3\u7801decodecpp","text":"#include <bits/stdc++.h> #define LL long long using namespace std ; int k ; void work () { LL n , e , d , ppq , pq ; scanf ( \"%lld%lld%lld\" , & n , & e , & d ); ppq = n + 2 - e * d ; pq = n ; LL l = 0 , r = ppq + 1 >> 1 ; while ( l < r ) { LL mid = ( l + r ) >> 1 ; if ( mid * ( ppq - mid ) < pq ) { l = mid + 1 ; } else r = mid ; } if ( l * ( ppq - l ) == pq && l <= ( ppq - l )) { printf ( \"%lld %lld \\n \" , l , ppq - l ); return ; } puts ( \"NO\" ); return ; } int main () { freopen ( \"decode.in\" , \"r\" , stdin ); freopen ( \"decode.out\" , \"w\" , stdout ); scanf ( \"%d\" , & k ); while ( k -- ) { work (); } return 0 ; }","title":"\u4ee3\u7801(decode.cpp)"},{"location":"match/csp2022/#t3","text":"\u5927\u6a21\u62df\uff0c\u4e07\u6076\u4e4b\u6e90 \u9a97\u4e86 \\(\\texttt{40pts}\\) \u4f46\u662f\u82b1\u4e86 \\(\\texttt{2h+}\\) \u5341\u5206\u4e0d\u5212\u7b97 \u5bfc\u81f4 T2\u3001T4 \u6302\u4e86","title":"T3"},{"location":"match/csp2022/#\u505a\u6cd5_2","text":"\u6211\u4e0d\u77e5\u9053","title":"\u505a\u6cd5"},{"location":"match/csp2022/#\u4ee3\u7801exprcpp","text":"\u6211\u66f4\u4e0d\u4f1a pr\u6211\u7231\u4f60","title":"\u4ee3\u7801(expr.cpp)"},{"location":"match/csp2022/#t4","text":"\u4e00\u4e2a\u52a8\u6001\u7f16\u7a0b\u9898\uff0c\u4f46\u6211\u53ea\u60f3\u5230 \\(\\texttt{60pts}\\) \u7684\u52a8\u6001\u7f16\u7a0b\u505a\u6cd5","title":"T4"},{"location":"match/csp2022/#\u505a\u6cd5_3","text":"\u8bbe \\(\\texttt{dp[i][k]}\\) \u4e3a\u5f53\u524d\u4e3a\u7b2c \\(i\\) \u4e2a\u70b9\uff0c\u7528\u4e86\u989d\u5916\u7684 \\(k\\) \u4e2a \u5916\u6302 \u6574\u70b9\u3002 \\(\\texttt{dp[i][k]} = \\max \\{\\texttt{dp[j][k-d]}\\}\\) ( \\(1 \\le j < i\\) \uff0c \\(d\\) \u4e3a\u4e24\u70b9\u95f4\u9700\u8981\u7528\u5230\u7684\u989d\u5916\u7684 \u5916\u6302 \u6574\u70b9) \u521d\u59cb\u65f6 \\(\\texttt{dp[i][k]}=1\\) \\(\\texttt{DP}\\) \u524d\u8981\u6392\u5e8f\uff0c\u5c31\u662f\u628a\u4e24\u4e2a\u70b9\uff0c\u5982\u679c \\(s1\\) \u80fd\u6401\u5230 \\(s2\\) \u5c31\u4e0d\u7528\u53d8\uff0c\u4e5f\u5c31\u662f \\(s1.x+s1.y<s2.x+s2.y\\)","title":"\u505a\u6cd5"},{"location":"match/csp2022/#\u4ee3\u7801pointcpp","text":"#include <bits/stdc++.h> using namespace std ; int ans , n , kk , f [ 510 ][ 110 ]; struct node { int x , y ; } a [ 510 ]; bool cmp ( node s1 , node s2 ) { return ( s1 . x + s1 . y ) < ( s2 . x + s2 . y ); } int main () { freopen ( \"point.in\" , \"r\" , stdin ); freopen ( \"point.out\" , \"w\" , stdout ); scanf ( \"%d%d\" , & n , & kk ); for ( int i = 1 ; i <= n ; i ++ ) { scanf ( \"%d%d\" , & a [ i ]. x , & a [ i ]. y ); } sort ( a + 1 , a + 1 + n , cmp ); for ( int i = 1 ; i <= n ; i ++ ) { for ( int k = 0 ; k <= kk ; k ++ ) { f [ i ][ k ] = 1 ; for ( int j = 1 ; j < i ; j ++ ) { if ( a [ i ]. x < a [ j ]. x || a [ i ]. y < a [ j ]. y ) continue ; int d = ( a [ i ]. x - a [ j ]. x ) + ( a [ i ]. y - a [ j ]. y ) -1 ; if ( k >= d ) { f [ i ][ k ] = max ( f [ i ][ k ], f [ j ][ k - d ] + d + 1 ); } } ans = max ( f [ i ][ k ] + ( kk - k ), ans ); } } printf ( \"%d \\n \" , ans ); return 0 ; }","title":"\u4ee3\u7801(point.cpp)"},{"location":"match/csp2022/#\u603b\u7ed3","text":"\u8fd9\u6b21\u6bd4\u8d5b\u51fa\u4e86\u4ebf\u70b9\u70b9\u5927\u5931\u8bef\uff0c\u5f53\u521d\u5e94\u8be5 \\(\\texttt{T1->T2->T4}\\) \u7136\u540e\u68c0\u67e5\uff0c\u518d\u8c61\u5f81\u6027\u5730\u9a97\u70b9 \\(\\texttt{T3}\\) \u7684\u5206\u3002 \u6211\u7231 CCF \u8d5e\u7f8e\u592a\u9633! \u5bc4! \u5e0c\u671b\u660e\u5e74\u53ef\u4ee5 RP++ \\(\\texttt{lzx's 2022 Round}\\) END","title":"\u603b\u7ed3"},{"location":"note/","text":"\u524d\u8a00-\u5b66\u4e60\u7b14\u8bb0 \u00b6 \u672c\u90e8\u5206\u4e3a lzx \u7684\u5b66\u4e60\u7b14\u8bb0\uff0c\u6301\u7eed\u5495\u5495\u5495","title":"\u524d\u8a00"},{"location":"note/#\u524d\u8a00-\u5b66\u4e60\u7b14\u8bb0","text":"\u672c\u90e8\u5206\u4e3a lzx \u7684\u5b66\u4e60\u7b14\u8bb0\uff0c\u6301\u7eed\u5495\u5495\u5495","title":"\u524d\u8a00-\u5b66\u4e60\u7b14\u8bb0"},{"location":"note/dddl/","text":"\u5355\u8c03\u961f\u5217\u5b66\u4e60\u7b14\u8bb0 \u00b6 \\(\\texttt{\u5982\u679c\u4e00\u4e2a\u9009\u624b\u6bd4\u4f60\u5c0f\u8fd8\u6bd4\u4f60\u5f3a\uff0c\u4f60\u5c31\u53ef\u4ee5\u9000\u5f79\u4e86\u3002--\u5355\u8c03\u961f\u5217}\\) \u7ef4\u62a4\u5355\u8c03\u6027\uff0c\u5f39\u51fa\u8fc7\u671f Luogu P1886 \u6ed1\u52a8\u7a97\u53e3 /\u3010\u6a21\u677f\u3011\u5355\u8c03\u961f\u5217 \u00b6 \u8d85\u8fc7 \\(k\\) \u5f39\u51fa\uff0c\u5982\u679c\u5f53\u524d\u66f4\u4f18\u5c31\u5c06\u961f\u5217\u91cc\u6bd4\u5b83\u4e0d\u4f18\u7684\u5f39\u51fa\uff0c\u6700\u540e \\(\\texttt{push}\\) \u8fdb\u53bb\u5b83 \u6309\u5c0f\u548c\u5927\u5404\u505a\u4e24\u904d\u5373\u53ef #include <bits/stdc++.h> using namespace std ; const int M = 1e6 + 10 ; int n , k , a [ M ], l , r , q [ M ]; int main () { scanf ( \"%d%d\" , & n , & k ); for ( int i = 1 ; i <= n ; i ++ ) { scanf ( \"%d\" , & a [ i ]); } l = 0 , r = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { while ( l <= r && q [ l ] + k <= i ) l ++ ; while ( l <= r && a [ q [ r ]] >= a [ i ]) r -- ; q [ ++ r ] = i ; if ( i >= k ) { printf ( \"%d \" , a [ q [ l ]]); } } puts ( \"\" ); l = 0 , r = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { while ( l <= r && q [ l ] + k <= i ) l ++ ; while ( l <= r && a [ q [ r ]] <= a [ i ]) r -- ; q [ ++ r ] = i ; if ( i >= k ) { printf ( \"%d \" , a [ q [ l ]]); } } return 0 ; } /* Write By : lzx RP++ -------------------- NOTES: */","title":"\u5355\u8c03\u961f\u5217\u5b66\u4e60\u7b14\u8bb0"},{"location":"note/dddl/#\u5355\u8c03\u961f\u5217\u5b66\u4e60\u7b14\u8bb0","text":"\\(\\texttt{\u5982\u679c\u4e00\u4e2a\u9009\u624b\u6bd4\u4f60\u5c0f\u8fd8\u6bd4\u4f60\u5f3a\uff0c\u4f60\u5c31\u53ef\u4ee5\u9000\u5f79\u4e86\u3002--\u5355\u8c03\u961f\u5217}\\) \u7ef4\u62a4\u5355\u8c03\u6027\uff0c\u5f39\u51fa\u8fc7\u671f","title":"\u5355\u8c03\u961f\u5217\u5b66\u4e60\u7b14\u8bb0"},{"location":"note/dddl/#luogu-p1886-\u6ed1\u52a8\u7a97\u53e3-\u6a21\u677f\u5355\u8c03\u961f\u5217","text":"\u8d85\u8fc7 \\(k\\) \u5f39\u51fa\uff0c\u5982\u679c\u5f53\u524d\u66f4\u4f18\u5c31\u5c06\u961f\u5217\u91cc\u6bd4\u5b83\u4e0d\u4f18\u7684\u5f39\u51fa\uff0c\u6700\u540e \\(\\texttt{push}\\) \u8fdb\u53bb\u5b83 \u6309\u5c0f\u548c\u5927\u5404\u505a\u4e24\u904d\u5373\u53ef #include <bits/stdc++.h> using namespace std ; const int M = 1e6 + 10 ; int n , k , a [ M ], l , r , q [ M ]; int main () { scanf ( \"%d%d\" , & n , & k ); for ( int i = 1 ; i <= n ; i ++ ) { scanf ( \"%d\" , & a [ i ]); } l = 0 , r = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { while ( l <= r && q [ l ] + k <= i ) l ++ ; while ( l <= r && a [ q [ r ]] >= a [ i ]) r -- ; q [ ++ r ] = i ; if ( i >= k ) { printf ( \"%d \" , a [ q [ l ]]); } } puts ( \"\" ); l = 0 , r = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { while ( l <= r && q [ l ] + k <= i ) l ++ ; while ( l <= r && a [ q [ r ]] <= a [ i ]) r -- ; q [ ++ r ] = i ; if ( i >= k ) { printf ( \"%d \" , a [ q [ l ]]); } } return 0 ; } /* Write By : lzx RP++ -------------------- NOTES: */","title":"Luogu P1886 \u6ed1\u52a8\u7a97\u53e3 /\u3010\u6a21\u677f\u3011\u5355\u8c03\u961f\u5217"},{"location":"other/","text":"\u524d\u8a00-\u5176\u4ed6 \u00b6 \u672c\u90e8\u5206\u4e3a lzx \u7684\u5176\u4ed6\u5185\u5bb9\uff0c\u6301\u7eed\u66f4\u65b0","title":"\u524d\u8a00"},{"location":"other/#\u524d\u8a00-\u5176\u4ed6","text":"\u672c\u90e8\u5206\u4e3a lzx \u7684\u5176\u4ed6\u5185\u5bb9\uff0c\u6301\u7eed\u66f4\u65b0","title":"\u524d\u8a00-\u5176\u4ed6"},{"location":"other/5min-to-make-test-data/","text":"\u4e94\u5206\u949f\u5b66\u5e9f\u4e0a\u4f20\u6d4b\u8bd5\u6570\u636e \u00b6 0.\u8bf4\u660e \u00b6 \u672c\u535a\u5ba2 3\u30014\u6b65\u9002\u7528\u4e8e Luogu 1. \u51c6\u5907 \u00b6 \u5728\u751f\u6210\u6570\u636e\u4e4b\u524d\uff0c\u60a8\u9700\u8981\u51c6\u5907\u6807\u7a0b\uff08\u63d0\u4ea4\u7b54\u6848\u9898\u9664\u5916\uff09\u3002 2. \u751f\u6210 \u00b6 \u60a8\u53ef\u4ee5\u7528\u53e4\u8001\u7684\u65b9\u6cd5\u751f\u6210\u6d4b\u8bd5\u6570\u636e\u3002 \u4e5f\u53ef\u4ee5\u4f7f\u7528\u4e0b\u9762\u7684\u751f\u6210\u5668: #include<bits/stdc++.h> #define RAND aabs(1LL*rand()*rand()*rand()*rand()*rand()*rand()*rand()) //rand\u8303\u56f4\u8fc7\u5c0f\uff0c\u81ea\u5df1\u53ef\u4ee5\u5f04\u4e00\u4e2a\uff08 #define LL long long using namespace std; LL aabs(LL x){ if(x<0) return -x; return x; } char INN[11]=\"001.in\"; char OUTN[12]=\"001.out\"; void data_in(int cc){//cc \u4ee3\u8868\u6570\u636e\u7f16\u53f7 freopen(INN,\"w\",stdout); //\u6570\u636e\u751f\u6210\u5668 } void data_out(){ freopen(INN,\"r\",stdin); freopen(OUTN,\"w\",stdout); //\u6807\u7a0b(\u8bb0\u5f97\u521d\u59cb\u5316) } int Number_Of_The_Test_Case=20;//\u53ef\u4ee5\u81ea\u5b9a\u4e49\uff0c\u8303\u56f4:1~999 int main(){ srand(time(0)+2147+4836*47);//\u53ef\u4ee5\u81ea\u5b9a\u4e49 clock_t t0=clock(); data_in(1); clock_t t1=clock();fprintf(stderr,\"\u7b2c 1 \u7ec4\u8f93\u5165\u6570\u636e\u751f\u6210\u5b8c\u6210, \u8017\u65f6 %lf s.\\n\",(t1-t0)/1000.0); data_out(); clock_t t2=clock();fprintf(stderr,\"\u7b2c 1 \u7ec4\u8f93\u51fa\u6570\u636e\u751f\u6210\u5b8c\u6210, \u8017\u65f6 %lf s.\\n\",(t2-t1)/1000.0); for(int i=2;i<=Number_Of_The_Test_Case;i++){ fprintf(stderr, \"---- \u5f00\u59cb\u751f\u6210\u7b2c %d \u7ec4\u6570\u636e ----\\n\", i); INN[0]=(i/100)+'0'; OUTN[0]=(i/100)+'0'; INN[1]=(i/10%10)+'0'; OUTN[1]=(i/10%10)+'0'; INN[2]=(i%10)+'0'; OUTN[2]=(i%10)+'0'; clock_t t0=clock(); data_in(i); clock_t t1=clock();fprintf(stderr,\"\u7b2c %d \u7ec4\u8f93\u5165\u6570\u636e\u751f\u6210\u5b8c\u6210, \u8017\u65f6 %lf s.\\n\",i,(t1-t0)/1000.0); data_out(); clock_t t2=clock();fprintf(stderr,\"\u7b2c %d \u7ec4\u8f93\u51fa\u6570\u636e\u751f\u6210\u5b8c\u6210, \u8017\u65f6 %lf s.\\n\",i,(t2-t1)/1000.0); } fprintf(stderr,\"\u5b8c\u6210!\\n\"); return 0; } 3. \u4e0a\u4f20 \u00b6 \ueb9f\ue783\ue74d \u5c06\u8fd9\u4e9b\u4e1c\u897f \u5168\u9009\uff0c\u538b\u7f29\u4e3a.zip\u683c\u5f0f\u7684\u538b\u7f29\u5305 \uff08\u538b\u7f29\u5305\u5185\u53ea\u5305\u542b\u6709.in .out\u7684\u6587\u4ef6\uff0c\u4e0d\u5305\u542b\u4efb\u4f55\u6587\u4ef6\u5939\uff09 \ueb9f\ue783\ue74d \u5230\u8981\u4e0a\u4f20\u6570\u636e\u7684\u9898\u91cc\uff0c\u70b9\u51fb\u201c\u7f16\u8f91\u9898\u76ee\u201d \ueb9f\ue783\ue74d \u8fdb\u5165\u540e\u70b9\u51fb\u201c\u6570\u636e\u70b9\u914d\u7f6e\u201d\u8fd9\u4e00\u7c7b\u522b\uff0c\u4e4b\u540e\u5bfb\u627e\u201c\u4e0a\u4f20\u6570\u636e\u201d\u5e76\u70b9\u51fb\uff0c\u9009\u62e9\u672c\u5730\u6587\u4ef6\u5e76\u8f93\u5165\u9a8c\u8bc1\u7801 4. \u6269\u5c55 \u00b6 \u5b50\u4efb\u52a1 \u00b6 \ueb9f\ue783\ue74d \u53ef\u4ee5\u5728\u6d4b\u8bd5\u6570\u636e\u9875\u9762\u66f4\u6539\u6570\u5b57\uff0c\u5982\u4e0a\u56fe\u3002 SPJ \u00b6 \u5f53\u4e00\u4e2a\u9898\u76ee\u53ef\u4ee5\u63a5\u53d7\u591a\u79cd\u6b63\u786e\u7b54\u6848,\u5373\u6709\u591a\u7ec4\u89e3\u7684\u65f6\u5019,\u9898\u76ee\u5c31\u5fc5\u987b\u88ab Special Judge\u3002 Special Judge \u7a0b\u5e8f\u4f7f\u7528\u8f93\u5165\u6570\u636e\u548c\u4e00\u4e9b\u5176\u4ed6\u4fe1\u606f\u6765\u5224\u7b54\u4f60\u7a0b\u5e8f\u7684\u8f93\u51fa\uff0c\u5e76\u5c06\u5224\u7b54\u7ed3\u679c\u8fd4\u56de\u3002 \u8be6\u89c1\uff1a Special Judge \u4f7f\u7528\u8bf4\u660e \u81ea\u5b9a\u4e49\u8ba1\u5206\u811a\u672c \u00b6 \u6709\u7684\u65f6\u5019\u51fa\u4e86\u4e00\u9053\u9898\u60f3\u8981\u81ea\u5b9a\u4e49\u6bd4\u8f83\u590d\u6742\u7684\u8ba1\u5206\u7b56\u7565\uff0c\u4f46\u662f\u5355\u9760 Subtask \u7684\u7ec4\u5408\u65e0\u6cd5\u6ee1\u8db3\uff0c\u8fd9\u65f6\u5019\u53ef\u4ee5\u4f7f\u7528\u8ba1\u5206\u811a\u672c\u3002 \u8be6\u89c1\uff1a \u81ea\u5b9a\u4e49\u8ba1\u5206\u811a\u672c \u4ea4\u4e92\u9898\u529f\u80fd\u8bf4\u660e \u00b6 \u4ea4\u4e92\u9898\u65e2\u7528\u6237\u63d0\u4ea4\u7684\u7a0b\u5e8f\uff0c\u901a\u8fc7\u51fa\u9898\u4eba\u63d0\u4f9b\u7684\u4ea4\u4e92\u5e93\uff0c\u4e0e\u5224\u9898\u7a0b\u5e8f\uff08SPJ\uff09\u8fdb\u884c\u4ea4\u4e92\u5e76\u83b7\u5f97\u8f93\u5165\u3001\u89e3\u7b54\u95ee\u9898\u3002 \u8be6\u89c1\uff1a \u4ea4\u4e92\u9898\u529f\u80fd\u8bf4\u660e","title":"\u4e94\u5206\u949f\u5b66\u5e9f\u4e0a\u4f20\u6d4b\u8bd5\u6570\u636e"},{"location":"other/5min-to-make-test-data/#\u4e94\u5206\u949f\u5b66\u5e9f\u4e0a\u4f20\u6d4b\u8bd5\u6570\u636e","text":"","title":"\u4e94\u5206\u949f\u5b66\u5e9f\u4e0a\u4f20\u6d4b\u8bd5\u6570\u636e"},{"location":"other/5min-to-make-test-data/#0\u8bf4\u660e","text":"\u672c\u535a\u5ba2 3\u30014\u6b65\u9002\u7528\u4e8e Luogu","title":"0.\u8bf4\u660e"},{"location":"other/5min-to-make-test-data/#1-\u51c6\u5907","text":"\u5728\u751f\u6210\u6570\u636e\u4e4b\u524d\uff0c\u60a8\u9700\u8981\u51c6\u5907\u6807\u7a0b\uff08\u63d0\u4ea4\u7b54\u6848\u9898\u9664\u5916\uff09\u3002","title":"1. \u51c6\u5907"},{"location":"other/5min-to-make-test-data/#2-\u751f\u6210","text":"\u60a8\u53ef\u4ee5\u7528\u53e4\u8001\u7684\u65b9\u6cd5\u751f\u6210\u6d4b\u8bd5\u6570\u636e\u3002 \u4e5f\u53ef\u4ee5\u4f7f\u7528\u4e0b\u9762\u7684\u751f\u6210\u5668: #include<bits/stdc++.h> #define RAND aabs(1LL*rand()*rand()*rand()*rand()*rand()*rand()*rand()) //rand\u8303\u56f4\u8fc7\u5c0f\uff0c\u81ea\u5df1\u53ef\u4ee5\u5f04\u4e00\u4e2a\uff08 #define LL long long using namespace std; LL aabs(LL x){ if(x<0) return -x; return x; } char INN[11]=\"001.in\"; char OUTN[12]=\"001.out\"; void data_in(int cc){//cc \u4ee3\u8868\u6570\u636e\u7f16\u53f7 freopen(INN,\"w\",stdout); //\u6570\u636e\u751f\u6210\u5668 } void data_out(){ freopen(INN,\"r\",stdin); freopen(OUTN,\"w\",stdout); //\u6807\u7a0b(\u8bb0\u5f97\u521d\u59cb\u5316) } int Number_Of_The_Test_Case=20;//\u53ef\u4ee5\u81ea\u5b9a\u4e49\uff0c\u8303\u56f4:1~999 int main(){ srand(time(0)+2147+4836*47);//\u53ef\u4ee5\u81ea\u5b9a\u4e49 clock_t t0=clock(); data_in(1); clock_t t1=clock();fprintf(stderr,\"\u7b2c 1 \u7ec4\u8f93\u5165\u6570\u636e\u751f\u6210\u5b8c\u6210, \u8017\u65f6 %lf s.\\n\",(t1-t0)/1000.0); data_out(); clock_t t2=clock();fprintf(stderr,\"\u7b2c 1 \u7ec4\u8f93\u51fa\u6570\u636e\u751f\u6210\u5b8c\u6210, \u8017\u65f6 %lf s.\\n\",(t2-t1)/1000.0); for(int i=2;i<=Number_Of_The_Test_Case;i++){ fprintf(stderr, \"---- \u5f00\u59cb\u751f\u6210\u7b2c %d \u7ec4\u6570\u636e ----\\n\", i); INN[0]=(i/100)+'0'; OUTN[0]=(i/100)+'0'; INN[1]=(i/10%10)+'0'; OUTN[1]=(i/10%10)+'0'; INN[2]=(i%10)+'0'; OUTN[2]=(i%10)+'0'; clock_t t0=clock(); data_in(i); clock_t t1=clock();fprintf(stderr,\"\u7b2c %d \u7ec4\u8f93\u5165\u6570\u636e\u751f\u6210\u5b8c\u6210, \u8017\u65f6 %lf s.\\n\",i,(t1-t0)/1000.0); data_out(); clock_t t2=clock();fprintf(stderr,\"\u7b2c %d \u7ec4\u8f93\u51fa\u6570\u636e\u751f\u6210\u5b8c\u6210, \u8017\u65f6 %lf s.\\n\",i,(t2-t1)/1000.0); } fprintf(stderr,\"\u5b8c\u6210!\\n\"); return 0; }","title":"2. \u751f\u6210"},{"location":"other/5min-to-make-test-data/#3-\u4e0a\u4f20","text":"\ueb9f\ue783\ue74d \u5c06\u8fd9\u4e9b\u4e1c\u897f \u5168\u9009\uff0c\u538b\u7f29\u4e3a.zip\u683c\u5f0f\u7684\u538b\u7f29\u5305 \uff08\u538b\u7f29\u5305\u5185\u53ea\u5305\u542b\u6709.in .out\u7684\u6587\u4ef6\uff0c\u4e0d\u5305\u542b\u4efb\u4f55\u6587\u4ef6\u5939\uff09 \ueb9f\ue783\ue74d \u5230\u8981\u4e0a\u4f20\u6570\u636e\u7684\u9898\u91cc\uff0c\u70b9\u51fb\u201c\u7f16\u8f91\u9898\u76ee\u201d \ueb9f\ue783\ue74d \u8fdb\u5165\u540e\u70b9\u51fb\u201c\u6570\u636e\u70b9\u914d\u7f6e\u201d\u8fd9\u4e00\u7c7b\u522b\uff0c\u4e4b\u540e\u5bfb\u627e\u201c\u4e0a\u4f20\u6570\u636e\u201d\u5e76\u70b9\u51fb\uff0c\u9009\u62e9\u672c\u5730\u6587\u4ef6\u5e76\u8f93\u5165\u9a8c\u8bc1\u7801","title":"3. \u4e0a\u4f20"},{"location":"other/5min-to-make-test-data/#4-\u6269\u5c55","text":"","title":"4. \u6269\u5c55"},{"location":"other/5min-to-make-test-data/#\u5b50\u4efb\u52a1","text":"\ueb9f\ue783\ue74d \u53ef\u4ee5\u5728\u6d4b\u8bd5\u6570\u636e\u9875\u9762\u66f4\u6539\u6570\u5b57\uff0c\u5982\u4e0a\u56fe\u3002","title":"\u5b50\u4efb\u52a1"},{"location":"other/5min-to-make-test-data/#spj","text":"\u5f53\u4e00\u4e2a\u9898\u76ee\u53ef\u4ee5\u63a5\u53d7\u591a\u79cd\u6b63\u786e\u7b54\u6848,\u5373\u6709\u591a\u7ec4\u89e3\u7684\u65f6\u5019,\u9898\u76ee\u5c31\u5fc5\u987b\u88ab Special Judge\u3002 Special Judge \u7a0b\u5e8f\u4f7f\u7528\u8f93\u5165\u6570\u636e\u548c\u4e00\u4e9b\u5176\u4ed6\u4fe1\u606f\u6765\u5224\u7b54\u4f60\u7a0b\u5e8f\u7684\u8f93\u51fa\uff0c\u5e76\u5c06\u5224\u7b54\u7ed3\u679c\u8fd4\u56de\u3002 \u8be6\u89c1\uff1a Special Judge \u4f7f\u7528\u8bf4\u660e","title":"SPJ"},{"location":"other/5min-to-make-test-data/#\u81ea\u5b9a\u4e49\u8ba1\u5206\u811a\u672c","text":"\u6709\u7684\u65f6\u5019\u51fa\u4e86\u4e00\u9053\u9898\u60f3\u8981\u81ea\u5b9a\u4e49\u6bd4\u8f83\u590d\u6742\u7684\u8ba1\u5206\u7b56\u7565\uff0c\u4f46\u662f\u5355\u9760 Subtask \u7684\u7ec4\u5408\u65e0\u6cd5\u6ee1\u8db3\uff0c\u8fd9\u65f6\u5019\u53ef\u4ee5\u4f7f\u7528\u8ba1\u5206\u811a\u672c\u3002 \u8be6\u89c1\uff1a \u81ea\u5b9a\u4e49\u8ba1\u5206\u811a\u672c","title":"\u81ea\u5b9a\u4e49\u8ba1\u5206\u811a\u672c"},{"location":"other/5min-to-make-test-data/#\u4ea4\u4e92\u9898\u529f\u80fd\u8bf4\u660e","text":"\u4ea4\u4e92\u9898\u65e2\u7528\u6237\u63d0\u4ea4\u7684\u7a0b\u5e8f\uff0c\u901a\u8fc7\u51fa\u9898\u4eba\u63d0\u4f9b\u7684\u4ea4\u4e92\u5e93\uff0c\u4e0e\u5224\u9898\u7a0b\u5e8f\uff08SPJ\uff09\u8fdb\u884c\u4ea4\u4e92\u5e76\u83b7\u5f97\u8f93\u5165\u3001\u89e3\u7b54\u95ee\u9898\u3002 \u8be6\u89c1\uff1a \u4ea4\u4e92\u9898\u529f\u80fd\u8bf4\u660e","title":"\u4ea4\u4e92\u9898\u529f\u80fd\u8bf4\u660e"},{"location":"other/about-memset/","text":"\u5173\u4e8e memset \u00b6 \u7b80\u8981 \u00b6 \\(\\texttt{memset}\\) \u539f\u7528\u5904\u662f\u521d\u59cb\u5316 \\(\\texttt{char}\\) \u7528\u7684\uff0c\u6545\u662f\u6309 \\(\\texttt{1}\\) \u4e2a\u5b57\u8282\u4e3a\u5355\u4f4d\u521d\u59cb\u7684\u3002 \u4f46\u73b0\u5728\u4e5f\u7528\u4e8e\u6570\u7ec4\u3002 \u7528\u6cd5 \u00b6 memset(\u6570\u7ec4\u540d\u5b57,\u503c,sizeof \u6570\u7ec4\u540d\u5b57) \u8fd9\u91cc\u7684 sizeof \u5e76\u975e\u51fd\u6570\uff0c\u800c\u662f \u5355\u76ee\u8fd0\u7b97\u7b26 \u4f8b\uff1a #include <bits/stdc++.h> using namespace std ; int a [ 114514 ]; signed main () { memset ( a , 0x3f , sizeof a ); cout << a [ 1 ] << \" \\n \" ; return 0 ; } \u8fd0\u884c\u7ed3\u679c\uff1a 1061109567 \u4e3a\u4ec0\u4e48\uff1f \u00b6 \u56e0\u4e3a\u4e0a\u9762\u8bf4\u662f\u6309\u7167 \\(1\\) \u4e2a\u5b57\u8282\u521d\u59cb\u7684\uff0c \\(1\\) \u4e2a \\(\\texttt{int}\\) \u5360 \\(4\\) \u4e2a\u5b57\u8282\uff0c \u6240\u4ee5\u6bcf\u4e2a\u6570\u7ec4\u7684\u503c\u662f \\(\\texttt{0x3f3f3f3f}\\) \uff0c\u4e5f\u5c31\u662f \\(10\\) \u8fdb\u5236\u4e0b\u7684 \\(1061109567\\) \u6ce8\u610f\uff1a\u91cc\u9762\u7684\u6570\u503c\u662f\u4ee5\u8865\u7801\u5b58\u50a8\u7684 \u6b63\u6570\u548c\u539f\u7801\u4e00\u6837 \u8d1f\u6570\u5728\u53cd\u7801\u57fa\u7840\u4e0a \\(+1\\) . \u6240\u4ee5 memset(a,255,sizeof a) \u540e\u6bcf\u4e00\u4f4d\u5c31\u662f \\(11111111\\) \uff0c\u56db\u4f4d\u5c31\u662f \\(32\\) \u4e2a \\(1\\) \u4f46\u7531\u4e8e\u7b2c\u4e00\u4f4d\u662f \u7b26\u53f7\u4f4d \uff0c\u4e14\u662f\u4ee5\u8865\u7801\u5f62\u5f0f\u5b58\u50a8\u7684\u3002 \u6240\u4ee5\u8be5\u6570\u4e3a\u8d1f\uff0c\u5e76\u4e14 \\(111\\dots\\) \u5171 \\(31\\) \u4e2a \\(1\\) \\(- 1\\) \uff08\u8865\u8f6c\u539f\uff09\u540e\u53d6\u53cd\u5c31\u4e3a \\(1\\) \uff08\u7701\u7565\u524d\u5bfc \\(0\\) \uff09 \u8f6c\u5341\u8fdb\u5236\u5c31\u662f \\(1\\) \uff0c\u52a0\u4e0a\u7b26\u53f7\u5c31\u662f \\(-1\\) \u3002 \u6240\u4ee5\u6bcf\u4e00\u4e2a \\(a_i\\) \u662f \\(-1\\) \u3002 \u8865\u5145 \u00b6 \u5f53\u6570\u503c\u8f6c \\(2\\) \u8fdb\u5236\u8d85\u8fc7 \\(8\\) \u4f4d\u90a3\u8d85\u8fc7\u7684\u5c31\u820d\u6389\uff0c\u4fdd\u7559\u540e \\(8\\) \u4f4d\u3002 \u4f8b\uff1a memset(a,257,sizeof a) \\(257_{10} = 100000001_{2}\\) \u540e\u516b\u4f4d\u5c31\u662f \\(00000001\\) \u56db\u4f4d\u5c31\u662f \\(00000001000000010000000100000001\\) \u4e5f\u5c31\u662f \\(16843009_{10}\\) \u6240\u4ee5\u6bcf\u4e00\u4e2a \\(a_i\\) \u662f \\(16843009\\) \u540e\u8bb0 \u00b6 \u5982\u679c\u6709\u95ee\u9898\u3001\u610f\u89c1\u6b22\u8fce\u79c1\u4fe1\u672c\u849f\u84bb","title":"\u5173\u4e8e memset"},{"location":"other/about-memset/#\u5173\u4e8e-memset","text":"","title":"\u5173\u4e8e memset"},{"location":"other/about-memset/#\u7b80\u8981","text":"\\(\\texttt{memset}\\) \u539f\u7528\u5904\u662f\u521d\u59cb\u5316 \\(\\texttt{char}\\) \u7528\u7684\uff0c\u6545\u662f\u6309 \\(\\texttt{1}\\) \u4e2a\u5b57\u8282\u4e3a\u5355\u4f4d\u521d\u59cb\u7684\u3002 \u4f46\u73b0\u5728\u4e5f\u7528\u4e8e\u6570\u7ec4\u3002","title":"\u7b80\u8981"},{"location":"other/about-memset/#\u7528\u6cd5","text":"memset(\u6570\u7ec4\u540d\u5b57,\u503c,sizeof \u6570\u7ec4\u540d\u5b57) \u8fd9\u91cc\u7684 sizeof \u5e76\u975e\u51fd\u6570\uff0c\u800c\u662f \u5355\u76ee\u8fd0\u7b97\u7b26 \u4f8b\uff1a #include <bits/stdc++.h> using namespace std ; int a [ 114514 ]; signed main () { memset ( a , 0x3f , sizeof a ); cout << a [ 1 ] << \" \\n \" ; return 0 ; } \u8fd0\u884c\u7ed3\u679c\uff1a 1061109567","title":"\u7528\u6cd5"},{"location":"other/about-memset/#\u4e3a\u4ec0\u4e48","text":"\u56e0\u4e3a\u4e0a\u9762\u8bf4\u662f\u6309\u7167 \\(1\\) \u4e2a\u5b57\u8282\u521d\u59cb\u7684\uff0c \\(1\\) \u4e2a \\(\\texttt{int}\\) \u5360 \\(4\\) \u4e2a\u5b57\u8282\uff0c \u6240\u4ee5\u6bcf\u4e2a\u6570\u7ec4\u7684\u503c\u662f \\(\\texttt{0x3f3f3f3f}\\) \uff0c\u4e5f\u5c31\u662f \\(10\\) \u8fdb\u5236\u4e0b\u7684 \\(1061109567\\) \u6ce8\u610f\uff1a\u91cc\u9762\u7684\u6570\u503c\u662f\u4ee5\u8865\u7801\u5b58\u50a8\u7684 \u6b63\u6570\u548c\u539f\u7801\u4e00\u6837 \u8d1f\u6570\u5728\u53cd\u7801\u57fa\u7840\u4e0a \\(+1\\) . \u6240\u4ee5 memset(a,255,sizeof a) \u540e\u6bcf\u4e00\u4f4d\u5c31\u662f \\(11111111\\) \uff0c\u56db\u4f4d\u5c31\u662f \\(32\\) \u4e2a \\(1\\) \u4f46\u7531\u4e8e\u7b2c\u4e00\u4f4d\u662f \u7b26\u53f7\u4f4d \uff0c\u4e14\u662f\u4ee5\u8865\u7801\u5f62\u5f0f\u5b58\u50a8\u7684\u3002 \u6240\u4ee5\u8be5\u6570\u4e3a\u8d1f\uff0c\u5e76\u4e14 \\(111\\dots\\) \u5171 \\(31\\) \u4e2a \\(1\\) \\(- 1\\) \uff08\u8865\u8f6c\u539f\uff09\u540e\u53d6\u53cd\u5c31\u4e3a \\(1\\) \uff08\u7701\u7565\u524d\u5bfc \\(0\\) \uff09 \u8f6c\u5341\u8fdb\u5236\u5c31\u662f \\(1\\) \uff0c\u52a0\u4e0a\u7b26\u53f7\u5c31\u662f \\(-1\\) \u3002 \u6240\u4ee5\u6bcf\u4e00\u4e2a \\(a_i\\) \u662f \\(-1\\) \u3002","title":"\u4e3a\u4ec0\u4e48\uff1f"},{"location":"other/about-memset/#\u8865\u5145","text":"\u5f53\u6570\u503c\u8f6c \\(2\\) \u8fdb\u5236\u8d85\u8fc7 \\(8\\) \u4f4d\u90a3\u8d85\u8fc7\u7684\u5c31\u820d\u6389\uff0c\u4fdd\u7559\u540e \\(8\\) \u4f4d\u3002 \u4f8b\uff1a memset(a,257,sizeof a) \\(257_{10} = 100000001_{2}\\) \u540e\u516b\u4f4d\u5c31\u662f \\(00000001\\) \u56db\u4f4d\u5c31\u662f \\(00000001000000010000000100000001\\) \u4e5f\u5c31\u662f \\(16843009_{10}\\) \u6240\u4ee5\u6bcf\u4e00\u4e2a \\(a_i\\) \u662f \\(16843009\\)","title":"\u8865\u5145"},{"location":"other/about-memset/#\u540e\u8bb0","text":"\u5982\u679c\u6709\u95ee\u9898\u3001\u610f\u89c1\u6b22\u8fce\u79c1\u4fe1\u672c\u849f\u84bb","title":"\u540e\u8bb0"},{"location":"sol/","text":"\u524d\u8a00-\u9898\u89e3 \u00b6 \u672c\u90e8\u5206\u4e3a lzx \u7684\u9898\u89e3\uff0c\u6301\u7eed\u66f4\u65b0","title":"\u524d\u8a00"},{"location":"sol/#\u524d\u8a00-\u9898\u89e3","text":"\u672c\u90e8\u5206\u4e3a lzx \u7684\u9898\u89e3\uff0c\u6301\u7eed\u66f4\u65b0","title":"\u524d\u8a00-\u9898\u89e3"}]}